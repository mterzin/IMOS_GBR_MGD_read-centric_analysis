---
title: "Analysis pipeline"
subtitle: "Code associated with the paper: Microbial Gene Content is a Strong Predictor of Water Chemistry across the Great Barrier Reef"
date: "`r format(Sys.time(), '%d %B, %Y')`"
documentclass: article
mainfont: Lato
output:
  html_document:
    code_folding: show
    collapse: no
    df_print: paged
    fig_caption: yes
    fig_height: 4
    fig_width: 4
    highlight: textmate
    theme: spacelab
    toc: yes
    toc_float: yes
    css: "/home/markoterzin/Documents/PhD/Thesis/Chapter_2/Data_analysis/Seawater/testing_Igor_Antti_R_script/All_seawater_full_dataset/resources/ws_style.css"
  pdf_document:
    toc: yes
    toc_depth: 3
    number_sections: yes
    df_print: kable
    fig_caption: true
    highlight: zenburn
    latex_engine: xelatex
  word_document:
#    fig_caption: yes
#    fig_height: 4
#    fig_width: 4
#    highlight: tango
    toc: yes
#    toc_depth: 2
# bibliography: ../resources/references.bib
fontsize: 11pt
geometry: margin=1in
classoption: a4paper
abstract: 
---

```{r Loading packages, echo=FALSE, results='hide', eval=TRUE, message=FALSE, warning=FALSE}
# Installing the necessary packages
list.of.packages <- c("lubridate",
                      "ggcorrplot",
                      "ncdf4",
                      "dplyr",
                      "plyr",
                      "data.table")
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages)

# Loading R packages
library(reshape2) # This is only needed for the melt funtion
library(reshape)
library(data.table)
library(ggplot2)
library(dplyr) # needed for data wrangling
library(tidyverse) # needed for data wrangling
library(plyr) # to joining multiple data frames (join_all function)
library(lubridate) # to separate date and time in spreadsheets
library(ggcorrplot) # to make a correlation plot as in Salazar et al 2019
library(data.table) # needed for data wrangling to find the nearest date
library(phyloseq)
library(ncdf4) # needed to load NCDF4 files
library(rstatix) # For the pull lower / upper triangle functions
# library(sysfonts) # To get Lato
library(mixOmics) # to do the PCAs for WQ and LTMP metrics
library(cowplot)

# Loading packages for the map
library(rworldmap)
library(rworldxtra)
# library(ggsn)
library(sf)
library(raster)
#library(rgeos)
library(maps)
# library(maptools)
library(grid)
library(miscTools)
library(stringr)
library(ggpubr)
library(gridExtra) # for arranging plots
library(ggspatial)
library(sf)
library(ggrepel) # The package ggrepel offers a very flexible approach to deal with label placement (with geom_text_repel and 
# geom_label_repel), including automated movement of labels in case of overlap
# Installing AIMS packages individually
library(remotes) # Needed to install the AIMS R packages below
# remotes::install_github("https://github.com/open-AIMS/dataaimsr")
library(dataaimsr)
# remotes::install_github("https://github.com/open-AIMS/gisaimsr")
library(gisaimsr)
library(sp)

# Libraries (from my script for the partial Mantel tests)
library(tidyverse)
library(dplyr)
library(raster)
library(data.table)
library(patchwork)
source("/home/markoterzin/Documents/PhD/Thesis/Chapter_2/Data_analysis/Seawater/Salazar_protocol/omrgc_v2_scripts-master/analysis/lib/sushipal.R")
source("/home/markoterzin/Documents/PhD/Thesis/Chapter_2/Data_analysis/Seawater/Salazar_protocol/omrgc_v2_scripts-master/analysis/lib/varpart.sqr.euc_functions.R")
palette(sushi.palette(alpha=0.7)[c(2,3,4,1,14)])
library(vegan)
library(readxl)
# library(R.utils)
library(ggcorrplot)
library(phyloseq)
# library(lmap) # needed for gdist function

# Setting the work directory
setwd("/home/markoterzin/Documents/PhD/Thesis/Chapter_2/Paper_drafts/the_analysis_is_finalised/Code")

# Loading the R object
# load("/home/markoterzin/Documents/PhD/Thesis/Chapter_2/Paper_drafts/the_analysis_is_finalised/Code/Code_for_Terzin_et_al_Microbial_Function_Outperforms_Taxonomy_in_Inferring_Water_Chemistry_across_the_Great_Barrier_Reef.RData")
```

# Field sampling design - ***IMOS GBR-MGD*** initiative 

Seawater samples were collected for (1) microbial metagenomics and (2) physico-chemical data (temperature, salinity, and particulate/dissolved nutrient concentrations) from 48 offshore reefs across the length of the GBR, within the Great Barrier Reef Microbial Genomics Database (***GBR-MGD***) initiative by Australia's Integrated Marine Observing System (***IMOS***). This sampling was done alongside ongoing **in situ** health surveys by the Australian Institute of Marine Science Long-Term Monitoring Program (***AIMS-LTMP***).

The code below was used to create a map showing the 48 IMOS GBR-MGD sites, by combining these two tutorials:
1. https://open-aims.github.io/gisaimsr/articles/examples.html
2. https://r-spatial.org/r/2018/10/25/ggplot2-sf-2.html

```{r Plotting the IMOS GBR MGD map, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE, fig.height=7, fig.width=7, fig.cap="Field sampling design for the GBR-MGD (Great Barrier Reef Microbial Genomics Database) dataset. (above) Seawater was collected from 48 offshore GBR reef sites for microbial community metagenomic sequencing and water chemistry analysis over four trips between November 2019 and July 2020. Reef sites are coloured in red or blue tones to denote trips that occurred during the austral summer (wet season) or austral winter (dry season), respectively. (bellow) A more detailed map showing the name of each reef site, and their membership to either offshore (41 reefs) or mid-shelf (7 reefs) waters. No inshore sites were sampled."}
# Importing the coordinates
map_coords <- read.csv("/home/markoterzin/Documents/PhD/Thesis/Chapter_2/Data_analysis/Seawater/testing_Tom_Jenkins_script/all_IMOS-MGD_seawater_subset/Metadata_files/MARKO_for_eReefs_Lats_Longs.csv")
# View(map_coords)

# Now converting from data frame into sf format
map_coords <- st_as_sf(map_coords, 
                       coords = c("lon", "lat"), 
                       remove = FALSE, 
                       crs = 4283, # this is the reference code for the CRS system GDA94, used by dataaimsr & gisaimsr R packages
                       agr = "constant")

# I will now add the info on Sampling trip - this will be needed when plotting

# This is the final metadata file, with average values of env. measurements (averaged per Reef site)
map_reef_names_and_trip <- read.csv(file = "/home/markoterzin/Documents/PhD/Thesis/Chapter_2/Paper_drafts/the_analysis_is_finalised/Code/input_files/metadata_with_reef_names_maps.csv") %>% 
  dplyr::select(REEF_NAME, Sampling_trip)

### 2 ### Renaming the sampling trips to include dates, and make sure they are ordered alphabetically
# First trip
map_reef_names_and_trip$Sampling_trip <- gsub("First", # String to search for
                               "Trip_01_Nov-Dec_2019", # Replace with this
                               as.character(map_reef_names_and_trip$Sampling_trip)) # Column to search in

# Second trip
map_reef_names_and_trip$Sampling_trip <- gsub("Second", # String to search for
                               "Trip_02_January_2020", # Replace with this
                               as.character(map_reef_names_and_trip$Sampling_trip)) # Column to search in

# Third trip
map_reef_names_and_trip$Sampling_trip <- gsub("Third", # String to search for
                               "Trip_03_February_2020", # Replace with this
                               as.character(map_reef_names_and_trip$Sampling_trip)) # Column to search in

# Fourth trip
map_reef_names_and_trip$Sampling_trip <- gsub("Fourth", # String to search for
                               "Trip_04_July_2020", # Replace with this
                               as.character(map_reef_names_and_trip$Sampling_trip)) # Column to search in

# Merging with 'Sampling trip' info
map_coords <- left_join(map_coords, map_reef_names_and_trip, by = c("name" = "REEF_NAME"))

#########################
# Now plotting

# And now defining colors for the map
cols_map <- c("tomato3", # Enclosed Coastal 
              "salmon3", # Macro Tidal Enclosed Coastal
              "pink3", # Macro Tidal Open Coastal
              "peachpuff", # Midshelf
              "lightsteelblue", # Offshore
              "lightcoral") # Open coastal

# Plotting without the mainland - otherwise I am just losing precious space
gbr_no_mainland <- gbr_feat %>%
  dplyr::filter(FEAT_NAME != "Mainland")

# ------------------------------------------------ #
# Overlaying IMOS-MGD sites - only as points first #
# ------------------------------------------------ #

col.per.trip <- factor(map_coords$Sampling_trip, levels = c("Trip_01_Nov-Dec_2019",
                                                            "Trip_02_January_2020",
                                                            "Trip_03_February_2020",
                                                            "Trip_04_July_2020"))
colors <- c("indianred", # Sampling trip 1
            "indianred4", # Sampling trip 2 
            "red3", # Sampling trip 3
            "slateblue") # Sampling trip 4
names(colors) <- c("Trip_01_Nov-Dec_2019",
                   "Trip_02_January_2020",
                   "Trip_03_February_2020",
                   "Trip_04_July_2020")

# Importing city coordinates
oz_cities <- read.csv("/home/markoterzin/Documents/PhD/Thesis/Chapter_2/Paper_drafts/the_analysis_is_finalised/Code/input_files/oz_cities.csv")

# Plot
IMOS_MGD_dots_trip = ggplot(data = gbr_feat) + # gbr_feat is a crs object from the AIMS GIS packages
  #  geom_sf(data = gbr_bounds, fill = "darkred", colour = NA) + # Coloring the boundaries of the GBR MP
# Include the region info too (the 3 lines below)
#    geom_sf(data = nrm_regions,
#  mapping = aes(fill = NAME), lwd = 0.01) +
#  scale_fill_brewer(name = "Region", palette = "Set3") +
  #  geom_sf(data = wbodies,
  #          mapping = aes(fill = MarineWate), # Commenting out as I don't need water bodies in color here
  #          lwd = 0.01) +
  geom_sf(data = gbr_feat,
          lwd = 0.01,
          fill = "seashell2",
          colour = NA
  ) +
##############################################################################################
# Adding our sites as dots
##############################################################################################
geom_sf(data = map_coords, # Needs to be a data frame, requires 'geometry'
        aes(color = Sampling_trip), # Coloring sites per sampling trip
        #        alpha = 0.6, # This is to ensure 
        show.legend = "point") +
  coord_sf(xlim = c(142, 154), ylim = c(-10, -27)) +
  geom_text_repel(data = oz_cities, aes(x = Longitude, y = Latitude, label = Town), # repel to make sure the names do not overlap
                  fontface = "bold", # to have the reef names in bold 
                  size=3.2, 
                  col = 'black',
                  nudge_x = c(-0.5, # Townsville
                              -0.9, # Brisbane
                              -0.5, # Cairns
                              -0.8, # Cooktown
                              -0.5, # Mackay
                              -0.7), # Bundaberg
                  nudge_y = c(-0.5, # Townsville
                              0.5, # Brisbane
                              -0.5, # Cairns
                              -0.5, # Cooktown
                              -0.5, # Mackay
                              -0.5), # Bundaberg
  )+ 
  scale_color_manual(name = "Dates of Sampling Transects", values=colors)+
  theme_classic() +
  theme(panel.background = element_rect(fill = "lightblue3",
                                        colour = "lightblue3",
                                        size = 0.5, linetype = "solid")) +
  labs(x = "Longitude",
       y = "Latitude",
       title = "IMOS-MGD",
       subtitle = "Microbial Genomics Database sites") +
#  scale_fill_manual(name = "Type of Water Body", values = cols_map) +
  theme(legend.direction = "vertical", legend.box = "vertical")
IMOS_MGD_dots_trip
```

```{r Plotting the IMOS GBR MGD map as black, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE, fig.height=6, fig.width=6, fig.cap="Field sampling design for the GBR-MGD (Great Barrier Reef Microbial Genomics Database) dataset. (above) Seawater was collected from 48 offshore GBR reef sites for microbial community metagenomic sequencing and water chemistry analysis over four trips between November 2019 and July 2020. Reef sites are coloured in red or blue tones to denote trips that occurred during the austral summer (wet season) or austral winter (dry season), respectively. (bellow) A more detailed map showing the name of each reef site, and their membership to either offshore (41 reefs) or mid-shelf (7 reefs) waters. No inshore sites were sampled."}
# Plot
IMOS_MGD_dots_trip_black = ggplot(data = gbr_feat) + # gbr_feat is a crs object from the AIMS GIS packages
  #  geom_sf(data = gbr_bounds, fill = "darkred", colour = NA) + # Coloring the boundaries of the GBR MP
# Include the region info too (the 3 lines below)
#    geom_sf(data = nrm_regions,
#  mapping = aes(fill = NAME), lwd = 0.01) +
#  scale_fill_brewer(name = "Region", palette = "Set3") +
  #  geom_sf(data = wbodies,
  #          mapping = aes(fill = MarineWate), # Commenting out as I don't need water bodies in color here
  #          lwd = 0.01) +
  geom_sf(data = gbr_feat,
          lwd = 0.01,
          fill = "black",
          colour = NA
  ) +
##############################################################################################
# Adding our sites as dots
##############################################################################################
geom_sf(data = map_coords, # Needs to be a data frame, requires 'geometry'
        aes(color = Sampling_trip), # Coloring sites per sampling trip
        #        alpha = 0.6, # This is to ensure 
        show.legend = "point") +
  coord_sf(xlim = c(142, 154), ylim = c(-10, -27)) +
  geom_text_repel(data = oz_cities, aes(x = Longitude, y = Latitude, label = Town), # repel to make sure the names do not overlap
                  fontface = "bold", # to have the reef names in bold 
                  size=3.2, 
                  col = 'black',
                  nudge_x = c(-0.5, # Townsville
                              -0.9, # Brisbane
                              -0.5, # Cairns
                              -0.8, # Cooktown
                              -0.5, # Mackay
                              -0.7), # Bundaberg
                  nudge_y = c(-0.5, # Townsville
                              0.5, # Brisbane
                              -0.5, # Cairns
                              -0.5, # Cooktown
                              -0.5, # Mackay
                              -0.5), # Bundaberg
  )+ 
  scale_color_manual(name = "Dates of Sampling Transects", values=colors)+
  theme_classic() +
  theme(panel.background = element_rect(fill = "lightblue3",
                                        colour = "lightblue3",
                                        size = 0.5,
                                        linetype = "solid"
                                        )) +
  labs(x = "Longitude",
       y = "Latitude",
       title = "IMOS-MGD",
       subtitle = "Microbial Genomics Database sites") +
#  scale_fill_manual(name = "Type of Water Body", values = cols_map) +
  theme(legend.direction = "vertical", legend.box = "vertical")
IMOS_MGD_dots_trip_black
```

To show reefs in more detail, we also plot a close-up of sites within each trip. 

```{r Splitting the map_coords file, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
# But need to split map_coords file per trip
map_coords_trip1 <- filter(map_coords, Sampling_trip=="Trip_01_Nov-Dec_2019")
map_coords_trip2 <- filter(map_coords, Sampling_trip=="Trip_02_January_2020")
map_coords_trip3 <- filter(map_coords, Sampling_trip=="Trip_03_February_2020")
map_coords_trip4 <- filter(map_coords, Sampling_trip=="Trip_04_July_2020")
```

```{r Map for IMOS MGD trip1, fig.height=7, fig.width=6, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
IMOS_MGD_trip1 = ggplot(data = gbr_feat) + # gbr_feat is a crs object from the AIMS GIS packages
  #  geom_sf(data = gbr_bounds, fill = "darkred", colour = NA) + # Coloring the boundaries of the GBR MP
  geom_sf() +
  #  geom_sf(data = wbodies,
  #          mapping = aes(fill = MarineWate), # Commenting out as I don't need water bodies in color here
  #          lwd = 0.01) +
  geom_sf(data = gbr_feat,
          lwd = 0.01,
          fill = "seashell2",
          colour = NA
  ) +
##############################################################################################
# Adding our sites as dots
##############################################################################################
geom_sf(data = map_coords_trip1, # Needs to be a data frame, requires 'geometry'
        aes(color = Sampling_trip), # Coloring sites per sampling trip
        show.legend = "point") +
  geom_text_repel(data = map_coords_trip1, aes(x = lon, y = lat, label = name, colour = Sampling_trip), # repel to make sure the names do not overlap
                  fontface = "bold", # to have the reef names in bold 
                  size=3.2, 
                  segment.color = "black",
                  segment.alpha = 0.6,
                  segment.size = 0.1,
                  nudge_x = c(2.2, # MCSWEENEY REEF 
                              2.4, # MONSOON REEF, - sign means it will move to the left 
                              1.2, # 11-049
                              1.2, # 11-162
                              0.9, # MANTIS REEF
                              1.6, # LAGOON REEF
                              0.4, # DAVIE REEF
                              -0.2, # CORBETT REEF
                              0.4, # 13-124
                              -0.1, # SANBANK 1 REEF
                              0.5), # St Crispin
                  # This should be 48 times, for our 48 sites
                  nudge_y = c(0.2, # MCSWEENEY REEF 
                              0.1, # MONSOON REEF 
                              0.1, # 11-049, - sign means it will go down
                              0.1, # 11-162
                              0.2, # MANTIS REEF
                              -0.3, # LAGOON REEF
                              0.2, # DAVIE REEF
                              -0.8, # CORBETT REEF
                              0.3, # 13-124
                              -1.6, # SANDBANK 1 REEF
                              0.5), ) + # St Crispin
  coord_sf(xlim = c(143, 147), ylim = c(-11, -16.5)) +
  scale_color_manual(name = "Sampling trip", values=c("indianred")) + # color I am using for Sampling trip 1
  theme_classic() +
  theme(panel.background = element_rect(fill = "lightblue3",
                                        colour = "lightblue3",
                                        size = 0.5, linetype = "solid")) +
  labs(x = "Longitude",
       y = "Latitude",
       title = "IMOS Microbial Genomics Database sites",
       subtitle = "Trip 1 (Nov-Dec 2019)")
  #  scale_fill_manual(name = "Type of Water Body", values = cols_map) +
#  theme(legend.direction = "vertical", legend.box = "vertical")
IMOS_MGD_trip1
```

```{r Map for IMOS MGD trip2, fig.height=7, fig.width=6, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
IMOS_MGD_trip2 = ggplot(data = gbr_feat) + # gbr_feat is a crs object from the AIMS GIS packages
  #  geom_sf(data = gbr_bounds, fill = "darkred", colour = NA) + # Coloring the boundaries of the GBR MP
  geom_sf() +
  #  geom_sf(data = wbodies,
  #          mapping = aes(fill = MarineWate), # Commenting out as I don't need water bodies in color here
  #          lwd = 0.01) +
  geom_sf(data = gbr_feat,
          lwd = 0.01,
          fill = "seashell2",
          colour = NA
  ) +
##############################################################################################
# Adding our sites as dots
##############################################################################################
geom_sf(data = map_coords_trip2, # Needs to be a data frame, requires 'geometry'
        aes(color = Sampling_trip), # Coloring sites per sampling trip
        show.legend = "point") +
  geom_text_repel(data = map_coords_trip2, aes(x = lon, y = lat, label = name, colour = Sampling_trip), # repel to make sure the names do not overlap
                  fontface = "bold", # to have the reef names in bold 
                  size=3.2, 
                  segment.color = "black",
                  segment.alpha = 0.6,
                  segment.size = 0.1,
                  nudge_x = c(-0.1, # FAIRFAX REEF
                    -0.4, # HOSKYN REEF
                    0.3, # BOULT REEF
                    0.3, # MASTHEAD REEF
                    -0.2, # ERSKINE REEF
                    0.4, # BROOMFIELD REEF
                    0.1, # 21-550
                    -0.5, # 22-084
                    0.4, # CHINAMAN REEF
                    -0.1, # 21-580
                    0.2, # SMALL LAGOON REEF
                    -0.3), # NORTH REEF
                  # This should be 48 times, for our 48 sites
                  nudge_y = c(-0.1, # FAIRFAX REEF
                    -0.1, # HOSKYN REEF
                    0.2, # BOULT REEF
                    -0.1, # MASTHEAD REEF
                    0.2, # ERSKINE REEF
                    0.2, # BROOMFIELD REEF
                    0.2, # 21-550
                    -0.3, # 22-084
                    0.2, # CHINAMAN REEF
                    -0.6, # 21-580
                    0.4, # SMALL LAGOON REEF
                    0.1), # NORTH REEF
                  ) + # SANDBANK 1 REEF
  coord_sf(xlim = c(151, 153), ylim = c(-21.5, -24)) +
  scale_color_manual(name = "Sampling trip", values=c("indianred4")) + # color I am using for Sampling trip 1
  theme_classic() +
  theme(panel.background = element_rect(fill = "lightblue3",
                                        colour = "lightblue3",
                                        size = 0.5,
                                        linetype = "solid")) +
  labs(x = "Longitude",
       y = "Latitude",
       title = "IMOS Microbial Genomics Database sites",
       subtitle = "Trip 2 (January 2020)")
  #  scale_fill_manual(name = "Type of Water Body", values = cols_map) +
#  theme(legend.direction = "vertical", legend.box = "vertical")
IMOS_MGD_trip2
```

```{r Map for IMOS MGD trip 3, fig.height=7, fig.width=6, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
IMOS_MGD_trip3 = ggplot(data = gbr_feat) + # gbr_feat is a crs object from the AIMS GIS packages
  #  geom_sf(data = gbr_bounds, fill = "darkred", colour = NA) + # Coloring the boundaries of the GBR MP
  geom_sf() +
  #  geom_sf(data = wbodies,
  #          mapping = aes(fill = MarineWate), # Commenting out as I don't need water bodies in color here
  #          lwd = 0.01) +
  geom_sf(data = gbr_feat,
          lwd = 0.01,
          fill = "seashell2",
          colour = NA
  ) +
##############################################################################################
# Adding our sites as dots
##############################################################################################
geom_sf(data = map_coords_trip3, # Needs to be a data frame, requires 'geometry'
        aes(color = Sampling_trip), # Coloring sites per sampling trip
        show.legend = "point") +
  geom_text_repel(data = map_coords_trip3, aes(x = lon, y = lat, label = name, colour = Sampling_trip), # repel to make sure the names do not overlap
                  fontface = "bold", # to have the reef names in bold 
                  size=3.2, 
                  segment.color = "black",
                  segment.alpha = 0.6,
                  segment.size = 0.1,
                  nudge_x = c(#0.3, # ST CRISPIN
                              0.3, # AGINCOURT1 REEF
                              0.3, # HASTINGS REEF
                              0.3, # ARLINGTON REEF
                              0.4, # THETFORD REEF
                              0.4, # MOORE REEF
                              0.3, # HEDLEY REEF
                              0.3, # MCCULLOCH REEF
                              0.4, # PEART REEF
                              0.4, # FEATHER REEF
                              0.1, # FARQUAHARSON REEF
                              0.3), # TAYLOR REEF
                  # This should be 48 times, for our 48 sites
                  nudge_y = c(#-0.1, # ST CRISPIN
                              0.2, # AGINCOURT1 REEF
                              0.2, # HASTINGS REEF
                              0.1, # ARLINGTON REEF
                              0.2, # THETFORD REEF
                              0.1, # MOORE REEF
                              0.1, # HEDLEY REEF
                              0.2, # MCCULLOCH REEF
                              0.1, # PEART REEF
                              -0.1, # FEATHER REEF
                              0.2, # FARQUAHARSON REEF
                              -0.1), # TAYLOR REEF
  ) +
  coord_sf(xlim = c(145.4, 147), ylim = c(-15.8, -18)) +
  scale_color_manual(name = "Sampling trip", values=c("red"))+
  theme_classic() +
  theme(panel.background = element_rect(fill = "lightblue3",
                                        colour = "lightblue3",
                                        size = 0.5,
                                        linetype = "solid")) +
  labs(x = "Longitude",
       y = "Latitude",
       title = "IMOS Microbial Genomics Database sites",
       subtitle = "Trip 3 (February 2020)") +
  #  scale_fill_manual(name = "Type of Water Body", values = cols_map) +
  theme(legend.direction = "vertical", legend.box = "vertical")
IMOS_MGD_trip3
```

```{r Map for IMOS MGD trip 4, fig.height=6, fig.width=8, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
IMOS_MGD_trip4 = ggplot(data = gbr_feat) + # gbr_feat is a crs object from the AIMS GIS packages
  #  geom_sf(data = gbr_bounds, fill = "darkred", colour = NA) + # Coloring the boundaries of the GBR MP
  geom_sf() +
  #  geom_sf(data = wbodies,
  #          mapping = aes(fill = MarineWate), # Commenting out as I don't need water bodies in color here
  #          lwd = 0.01) +
  geom_sf(data = gbr_feat,
          lwd = 0.01,
          fill = "seashell2",
          colour = NA
  ) +
  ##############################################################################################
# Adding our sites as dots
##############################################################################################
geom_sf(data = map_coords_trip4, # Needs to be a data frame, requires 'geometry'
        aes(color = Sampling_trip), # Coloring sites per sampling trip
        show.legend = "point") +
  geom_text_repel(data = map_coords_trip4, aes(x = lon, y = lat, label = name, colour = Sampling_trip), # repel to make sure the names do not overlap
                  fontface = "bold", # to have the reef names in bold 
                  size=3.2, 
                  segment.color = "black",
                  segment.alpha = 0.6,
                  segment.size = 0.1,
                  nudge_x = c(-0.2, # LITTLE KELSO REEF
                              -0.2, # KELSO REEF
                              0.5, # ROXBURGH REEF
                              0.2, # FORE&AFT REEF
                              0.2, # RIB REEF
                              -0.1, # JOHN BREWER REEF
                              0.1, # MYRMIDON REEF
                              -0.3, # CHICKEN REEF
                              0.3, # KNIFE REEF
                              0.2, # FORK REEF
                              0.2, # LYNCHS REEF
                              -0.1, # CENTIPEDE REEF
                              -0.1, # GRUB REEF
                              -0.2), # HELIX REEF
                  # This should be 48 times, for our 48 sites
                  nudge_y = c(-0.2, # LITTLE KELSO REEF
                              -0.1, # KELSO REEF
                              0.1, # ROXBURGH REEF
                              0, # FORE&AFT REEF
                              0.1, # RIB REEF
                              -0.2, # JOHN BREWER REEF
                              0.1, # MYRMIDON REEF
                              -0.3, # CHICKEN REEF
                              0.1, # KNIFE REEF
                              0, # FORK REEF
                              -0.2, # LYNCHS REEF
                              -0.1, # CENTIPEDE REEF
                              -0.1, # GRUB REEF
                              -0.2), # HELIX REEF
  ) +
  coord_sf(xlim = c(146.8, 148), ylim = c(-18.1, -19)) +
  scale_color_manual(name = "Sampling trip", values=c("slateblue"))+
  theme_classic() +
  theme(panel.background = element_rect(fill = "lightblue3",
                                        colour = "lightblue3",
                                        size = 0.5,
                                        linetype = "solid")) +
  labs(x = "Longitude",
       y = "Latitude",
       title = "IMOS Microbial Genomics Database sites",
       subtitle = "Trip 4 (July 2020)") +
  #  scale_fill_manual(name = "Type of Water Body", values = cols_map) +
  theme(legend.direction = "vertical", legend.box = "vertical")
IMOS_MGD_trip4
```

```{r Per trip maps together, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE, fig.height=7, fig.width=24}
plot_grid(IMOS_MGD_trip1, IMOS_MGD_trip2, IMOS_MGD_trip3, IMOS_MGD_trip4,
          nrow = 1,
          ncol = 4)
```


# Physico-chemical data - collection, pre-processing, and analysis

```{r Importing physico-chemical data, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
wrangling <- read.csv("/home/markoterzin/Documents/PhD/Thesis/Chapter_2/Paper_drafts/the_analysis_is_finalised/Code/input_files/metadata_wrangling.csv")

WQ_methods <- read.csv("/home/markoterzin/Documents/PhD/Thesis/Chapter_2/Paper_drafts/the_analysis_is_finalised/Code/input_files/WQ_IDs_IMOS-MGD_only.csv")
# And this is one of the WQ spreadsheets - link between WQ IDs and our Reef names 

# Selecting only the columns of interest
WQ_methods <- dplyr::select(WQ_methods, one_of(c("REEF_NAME",
                                          "WQ_Station_Name",
                                          "Collection_method", # diving or from boat
                                          "Sample_collection_start")))#,
# We decided not to include the metrics bellow
                                          # "Swell_direction",
                                          # "Swell_height",
                                          # "Wind_direction",
                                          #"Wind_speed" )))

# Additional data from the LTMP trips
LTMP <- read.csv("/home/markoterzin/Documents/PhD/Thesis/Chapter_2/Paper_drafts/the_analysis_is_finalised/Code/input_files/metadata_IMOS_from_Mike.csv") %>% 
  dplyr::select("REEF_NAME", "Sampling_trip", "GBR_sector", "SAMPLE_DATE", "Lat", "Long")
### 2 ### Renaming the sampling trips to include dates, and make sure they are ordered alphabetically
# First trip
LTMP$Sampling_trip <- gsub("First", # String to search for
                               "Trip_01_Nov-Dec_2019", # Replace with this
                               as.character(LTMP$Sampling_trip)) # Column to search in

# Second trip
LTMP$Sampling_trip <- gsub("Second", # String to search for
                               "Trip_02_January_2020", # Replace with this
                               as.character(LTMP$Sampling_trip)) # Column to search in

# Third trip
LTMP$Sampling_trip <- gsub("Third", # String to search for
                               "Trip_03_February_2020", # Replace with this
                               as.character(LTMP$Sampling_trip)) # Column to search in

# Fourth trip
LTMP$Sampling_trip <- gsub("Fourth", # String to search for
                               "Trip_04_July_2020", # Replace with this
                               as.character(LTMP$Sampling_trip)) # Column to search in

# Joining - first step
metadata <- left_join(wrangling, LTMP)
# In this step I added the Sample IDs to the LTMP data
metadata <- left_join(metadata, WQ_methods)
# And in here the info from the WQ team

# importing the actual water chemistry measurements
WQ_Result_Report <- read.csv("/home/markoterzin/Documents/PhD/Thesis/Chapter_2/Paper_drafts/the_analysis_is_finalised/Code/input_files/MBM_Result_Report_R_Dec_2022.csv")

# Removing Temperature and Salinity for now - too many missing values
WQ_Result_Report <- dplyr::select(WQ_Result_Report, one_of(c("WQ_Station_Name",
                                                      "DEPTH",
                                                      "Chlorophyll_a_.µg.L.",
                                                      "Phaeophytin_a_.µg.L.",
                                                      "PN_.µM.",
                                                      "POC_.µM.",
                                                      "PP_.µM.",
                                                      "DOC_.µM.",
                                                      "PO4_.µM.",
                                                      "NH4_.µM.",
                                                      "NO2_.µM.",
                                                      "NO3_.µM.",
                                                      "Si_.µM.",
                                                      "TDN_.µM.",
                                                      "TDP_.µM.",
                                                      "TSS_.mg.L.")))
                                                      # "Salinity",
                                                      # "Temperature.C..")))

# Now adding the Reef_name info
wq.all.reps.for.pca <- left_join(WQ_methods, WQ_Result_Report)

# I also need the info on Sampling trips - to color the groups on the PCA. I will also add the data from the research vessel at this stage - Temperature, Salinity, Turbidity, Fluorescence
reefs_trips <- read.csv("/home/markoterzin/Documents/PhD/Thesis/Chapter_2/Paper_drafts/the_analysis_is_finalised/Code/input_files/metadata_with_reef_names.csv")
# But I only want reef names and their corresponding trips for now!
reefs_trips <- reefs_trips[,c(1,3)]

### 2 ### Renaming the sampling trips to include dates, and make sure they are ordered alphabetically
# First trip
reefs_trips$Sampling_trip <- gsub("First", # String to search for
                                              "Trip_01_Nov-Dec_2019", # Replace with this
                                              as.character(reefs_trips$Sampling_trip)) # Column to search in

# Second trip
reefs_trips$Sampling_trip <- gsub("Second", # String to search for
                                              "Trip_02_January_2020", # Replace with this
                                              as.character(reefs_trips$Sampling_trip)) # Column to search in

# Third trip
reefs_trips$Sampling_trip <- gsub("Third", # String to search for
                                              "Trip_03_February_2020", # Replace with this
                                              as.character(reefs_trips$Sampling_trip)) # Column to search in

# Fourth trip
reefs_trips$Sampling_trip <- gsub("Fourth", # String to search for
                                              "Trip_04_July_2020", # Replace with this
                                              as.character(reefs_trips$Sampling_trip)) # Column to search in

# Now adding the metadata from the RV
vessel_metadata <- read.csv("/home/markoterzin/Documents/PhD/Thesis/Chapter_2/Paper_drafts/the_analysis_is_finalised/Code/input_files/GBR-Genomics-Database_Seawater-Illumina-Reads.csv")
# Keeping only: Temperature, Salinity, Turbidity, Fluorescence
vessel_metadata <- dplyr::select(vessel_metadata, one_of(c("REEF_NAME",
                                                           "SEAWATER_TEMPERATURE_2.5m_RV",
                                                           "SALINITY_2.5m_RV",
#                                                           "TURBIDITY_2.5m_RV",
                                                           "FLUORESCENCE_2.5m_RV")))

# Joining now
reefs_trips <- left_join(reefs_trips,
                         vessel_metadata)
wq.all.reps.for.pca <- left_join(wq.all.reps.for.pca,
                                 reefs_trips)
```

### ***P***rincipal ***C***omponents ***A***nalysis (***PCA***) - What are the main clustering patterns between our reefs based on physico-chemical data?

PCA was applied on a physico-chemical dataset containing 17 variables, including:
1. 14 water chemistry variables: ammonia (NH4), nitrite (NO2), nitrate (NO3), total dissolved nitrogen (TDN), phosphate (PO4), total dissolved phosphorus (TDP), dissolved organic carbon (DOC), silicate (Si), total suspended solids (TSS), chlorophyll a (Chl-a), phaeophytin a (Phaeo), particulate organic carbon (POC), particulate nitrogen (PN), and particulate phosphorus (PP). For each of these 14 water chemistry variables, triplicate 5 L seawater samples were collected using Niskin bottles for analysis of water chemistry variables, at each of the 48 reefs.
2. temperature, fluorescence, and salinity measurements from the underway sampling systems on the RV Solander and RV Cape Ferguson, with intake depths for underway systems were 1.9 m (RV Cape Ferguson) and 2.5 m (RV Solander). For these three measurements, one value per reef site was recorded.

#### Choosing the number of components 

The mixOmics function tune.pca() calculates the cumulative proportion of explained variance for a large number of principal components (here we set ncomp = 10). A screeplot of the proportion of explained variance relative to the total amount of variance in the data for each principal component is output.

```{r PCA based on physico-chemical data Tuning, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE, fig.cap="Screeplot from the PCA performed on the IMOS GBR-MGD physico-chemical data: Amount of explained variance for each principal component is shown. From the numerical output (shown bellow in tabular format), we observe that the first two principal components explain 60.31% of the total variance. The rule of thumb for choosing the number of PCA components is not so much to set a hard threshold based on the cumulative proportion of explained variance (as this is data-dependent), but to observe when a drop, or elbow, appears on the screeplot. The elbow indicates that the remaining variance is spread over many principal components and is not relevant in obtaining a low-dimensional ‘snapshot’ of the data. Based on this, we chose to keep two PCA dimensions.", fig.height=4, fig.width=6}
# In PCA, we first count the number of missing values, as this will tell us whether PCA will be solved using SVD (no missing values) or iterative NIPALS (with missing values) internally in the mixOmics function pca().
sum(is.na(wq.all.reps.for.pca[,c(6:14, 16:23)]))
# Number of NAs
## [1] 17
# Since we have some missing values, the iterative NIPALS will be called inside pca()

tune.pca.WQ <- tune.pca(wq.all.reps.for.pca[,c(6:14, 16:23)], ncomp = 10, scale = TRUE)
plot(tune.pca.WQ)

# Numerical output
pca.wq.all.reps <- pca(wq.all.reps.for.pca[,c(6:14, 16:23)], # getting the numerical values only
                       ncomp = 10,
                       center = TRUE,
                       scale = TRUE)

# Explained variance per PCA component
knitr::kable(pca.wq.all.reps$prop_expl_var$X, caption = "The proportion of explained variance per each PCA component is:")
# The cumulative proportion of variance explained by each PCA component
knitr::kable(pca.wq.all.reps$cum.var, caption = "The cumulative proportion of variance explained by each PCA component")
```

#### Visualising patterns based on the final PCA model (with only the first two PCA dimensions)

```{r final PCA sample plot physico-chemical data all reps color per trip, fig.width = 10, fig.height=6, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
PCA_WQ_sample_plot <- plotIndiv(pca.wq.all.reps,
          comp = c(1, 2), 
          group = wq.all.reps.for.pca$Sampling_trip, 
#          ind.names = wq.all.reps.for.pca$REEF_NAME,
          ellipse = T,
          col.per.group =c("indianred", # Sampling trip 1
                           "indianred4", # Sampling trip 2 
                           "red3", # Sampling trip 3
                           "slateblue"), # Sampling trip 4
          legend = TRUE,
          title = 'WQ Metadata all reps, PCA comp 1 - 2')

PCA_WQ_biplot <- biplot(pca.wq.all.reps,
       comp = c(1, 2), 
       group = wq.all.reps.for.pca$Sampling_trip,
#       ind.names = wq.all.reps.for.pca$REEF_NAME,
       col.per.group =c("indianred", # Sampling trip 1
                        "indianred4", # Sampling trip 2
                        "red3", # Sampling trip 3
                        "slateblue"), # Sampling trip 4
       legend = TRUE,
       legend.title = "Sampling trip",
       title = 'PCA biplot for WQ Metadata all reps, PCA comp 1 - 2')
```

```{r PCA WQ sample plot and biplot merged, fig.width = 10, fig.height=13, echo=TRUE, cache=TRUE, results='hide', eval=TRUE, message=FALSE, warning=FALSE, echo=FALSE, cache=TRUE, fig.cap="PCA sample plot (above) and PCA biplot (below), both computed using the first two PCA dimensions. Reef sites are coloured in red or blue tones to denote trips that occurred during the austral summer (wet season) or austral winter (dry season), respectively. These were merged later in Inkscape to create a plot for the main Figure."}
# patchwork::wrap_plots(PCA_WQ_sample_plot$graph,
#                      PCA_WQ_biplot,
#                      nrow = 2, ncol = 1)
```

The PCA results suggest that our water chemistry measurements from across the GBR were largely driven by seasonality, while geography had a weaker influence. Chemistry profiles of samples collected in early austral summer were comparable despite being >1500 km apart in the far north (Cape Grenville and Princess Charlotte bay sectors) and far south (Swains and Capricorn Bunker sectors) of the GBR, whereas samples collected during the peaks of austral summer and winter were the most distinct although they were geographically close in the central GBR (~200 km apart, Cairns and Cooktown / Lizard island sectors for austral summer samples, and Innisfail and Townsville sectors for austral winter samples). Further, we observe that summer trips 1-3 were characterised by elevated temperature and higher concentrations of dissolved and particulate nutrients, apart frpm TDP and phosphate which were elevated during winter.

However, we did not show reef names in either of the PCA plots as there is an overlap between data points (and hence the text is not readable), and also in these PCA visualisations, we lose context of raw values. This information was added with a heatmap (to compare physico-chemical metrics across sites) and with boxplots (which show the raw physico-chemical measurements).

#### Heatmap showing physico-chemical measurements across sites

We first collapsed the data to a ***mean/median*** value because for each of the 17 environmental metrics we computed the median value per reef site as the number of Niskin deployments differed for molecular (four replicates) and water chemistry (three replicates) sampling.

```{r Mean and median WQ measurements, echo=FALSE, results='hide', eval=TRUE, message=FALSE, warning=FALSE}
# Now getting the average values per reef site
WQ_Result_Report_mean <- ddply(WQ_Result_Report, # This is my data frame
                .(WQ_Station_Name), summarize, # Grouping per reef name
                # Computing mean values below, and renaming columns
                mean_Chlorophyll_A_µg_L=mean(Chlorophyll_a_.µg.L., na.rm=T),
                mean_Phaeophytin_A_µg_L=mean(Phaeophytin_a_.µg.L., na.rm=T),
                mean_PN_µM=mean(PN_.µM., na.rm=T),
                mean_POC_µM=mean(POC_.µM., na.rm=T),
                mean_PP_µM=mean(PP_.µM., na.rm=T),
                mean_DOC_µM=mean(DOC_.µM., na.rm=T), 
                mean_PO4_µM=mean(PO4_.µM., na.rm=T),
                mean_NH4_µM=mean(NH4_.µM., na.rm=T),
                mean_NO2_µM=mean(NO2_.µM., na.rm=T),
                mean_NO3_µM=mean(NO3_.µM., na.rm=T),
                mean_Si_µM=mean(Si_.µM., na.rm=T),
                mean_TDN_µM=mean(TDN_.µM., na.rm=T),
                mean_TDP_µM=mean(TDP_.µM., na.rm=T),
                mean_TSS_mg_L=mean(TSS_.mg.L., na.rm=T)
                )

WQ_Result_Report_median <- ddply(WQ_Result_Report, # This is my data frame
                .(WQ_Station_Name), summarize, # Grouping per reef name
                # Computing median values below, and renaming columns
                median_Chlorophyll_A_µg_L=median(Chlorophyll_a_.µg.L., na.rm=T),
                median_Phaeophytin_A_µg_L=median(Phaeophytin_a_.µg.L., na.rm=T),
                median_PN_µM=median(PN_.µM., na.rm=T),
                median_POC_µM=median(POC_.µM., na.rm=T),
                median_PP_µM=median(PP_.µM., na.rm=T),
                median_DOC_µM=median(DOC_.µM., na.rm=TRUE), 
                median_PO4_µM=median(PO4_.µM., na.rm=T),
                median_NH4_µM=median(NH4_.µM., na.rm=T),
                median_NO2_µM=median(NO2_.µM., na.rm=T),
                median_NO3_µM=median(NO3_.µM., na.rm=T),
                median_Si_µM=median(Si_.µM., na.rm=T),
                median_TDN_µM=median(TDN_.µM., na.rm=T),
                median_TDP_µM=median(TDP_.µM., na.rm=T),
                median_TSS_mg_L=median(TSS_.mg.L., na.rm=T)
                )

# Important! na.rm parameter is not to consider missing values - otherwise I would be getting a zero

# Double-checking for mean and/or median vals that may be zero
WQ_Result_Report_mean[WQ_Result_Report_mean == 0]
WQ_Result_Report_median[WQ_Result_Report_median == 0]
# Looks good!

# Merging
metadata <- left_join(metadata, WQ_Result_Report_mean)
metadata <- left_join(metadata, WQ_Result_Report_median)
# Also adding the vessel meatadata - already averaged per site!
metadata <- left_join(metadata, vessel_metadata)

# Last step - renaming the sample ID to shorten the names. This also makes the names comparable to the naming scheme of metagenomics data, which will be important when merging metadata with the biom files to create a single phyloseq object

### 1 ### Replacing the '_interleaved_subset_0-05_1' with the '_R1' string in the Sample_ID name  
metadata$Sample_ID <- gsub("_interleaved_subset_0-05_1", # String to search for
                           "_R1", # Replace with nothing
                           as.character(metadata$Sample_ID))  # Column to search in
metadata <- metadata %>%
  as.data.frame() %>% 
  column_to_rownames("Sample_ID")
```

```{r Heatmap with physico chemical measurements scaled across sites, fig.height=5, fig.width=14, fig.cap="The heatmap shows the level of change in all 17 physico-chemical variables (y axis) across the reef sites (x axis), grouped within their corresponding sampling trip. Environmental measurements were centered (median = 0) and scaled (standard deviation (SD) = 1) across reef sites, and values that deviate from the median (0) were shown in red (> median) and blue (< median). This heatmap was combined in Inkscape with the PCA visualisation for physico-chemical data to re-introduce the context of reef sites, which were not visualised in the PCA.", echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
# Making the heatmap of LTMP data
WQ_heatmap <- metadata[,24:40] %>% # I am only choosing columns with median values
  scale(center = TRUE, scale = TRUE) %>% # I wand the values to be scaled
  as.data.frame() %>% # Converting back to data frame - ggplot needs this
  rownames_to_column("Sample_ID") %>% # Setting rownames as Col 1 - will need this for melting
  reshape2::melt() %>% # Getting the long format - this is what geom_tile needs
  left_join(metadata[, c(1,2)] # adding back the REEF NAME and SAMPLING TRIP vars
            %>% rownames_to_column("Sample_ID")
            ) %>% # Need to convert row names to Column 1 and give Sample_ID as name, because I am joining those with the same ID
  ggplot(aes(x = REEF_NAME, y = variable, fill = value)) +
  geom_tile() + # Plotting the heatmap here
  scale_fill_gradient2(low = "#075AFF",
                       mid = "#FFFFCC",
                       high = "#FF0000") + # The coloring scheme - red for high vals, blue for low
  facet_wrap(~Sampling_trip, scales = "free_x", ncol = 4) + # now facetting reef sites based on the Sampling trip
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 8))
WQ_heatmap
```

#### Box plots showing raw physico-chemical measurements, as well as mean and median values

```{r WQ boxplots per sampling trip with fixed y axis across, fig.height=18, fig.width=9, fig.cap="FIG CAP TO BE ADDED.", warning=FALSE, message=FALSE}
# Median is the default in ggplot2
reshape2::melt(wq.all.reps.for.pca[,c(1, # Reef name
                                      6:19, # All numerical vals
                                      21, # Temperature
                                      22, # Salinity
                                      23, # Fluorescence
                                      20)]) %>% # Sampling trip
  ggplot(aes(y = value,
             x = Sampling_trip,
             fill = Sampling_trip),
         alpha=0.8) +
  geom_boxplot(#outlier.colour="red",
               outlier.shape=8,
               outlier.size=4) +
  geom_jitter(alpha = 0.6,
              size = 0.8) +
  stat_summary(fun=mean,
               geom="point",
               shape=20,
               size=0.8,
               color="seagreen1",
               fill="seagreen1") + # Plotting the mean as a green dot!
  facet_grid(rows = vars(variable),
             cols = vars(Sampling_trip),
             scales = "free"
             ) +
  scale_fill_manual(values = c("indianred", # Sampling trip 1
                           "indianred4", # Sampling trip 2 
                           "red3", # Sampling trip 3
                           "slateblue") # Sampling trip 4
                    ) +
  labs(y = "WQ metrics",
       x = "Reef sites",
       title = "Boxplots for WQ metrics (Median & Mean)"
       ) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, size = 8))
```

Getting the numerical summary of physico-chemical variables

```{r Tables with mean median sd per trip for Renee, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
# Data needs to be in long format
wq_median_per_trip <- reshape2::melt(wq.all.reps.for.pca[,c(1, # Reef name
                                      6:19, # All numerical vals
                                      21, # Temperature
                                      22, # Salinity
                                      23, # Fluorescence
                                      20)]) %>% # Sampling_trip
  as.data.frame() %>% 
  group_by(Sampling_trip, variable) %>% 
# Now computing mean and SD
dplyr::summarize( # This tutorial for troubleshooting! https://stackoverflow.com/questions/46661461/calculate-mean-by-group-using-dplyr-package
          median=round(median(value, na.rm=TRUE),
                       digits = 2)
          ) %>%
  reshape2::dcast(variable~Sampling_trip)
# Showing as table
knitr::kable(wq_median_per_trip, caption = "Median for all 17 physico-chemical metrics, collapsed across the four sampling trips.")

# Data needs to be in long format
wq_mean_per_trip <- reshape2::melt(wq.all.reps.for.pca[,c(1, # Reef name
                                      6:19, # All numerical vals
                                      21, # Temperature
                                      22, # Salinity
                                      23, # Fluorescence
                                      20)]) %>% # Sampling_trip
  as.data.frame() %>% 
  group_by(Sampling_trip, variable) %>% 
# Now computing mean and SD
dplyr::summarize( # This tutorial for troubleshooting! https://stackoverflow.com/questions/46661461/calculate-mean-by-group-using-dplyr-package
          mean=round(mean(value, na.rm=TRUE),
                     digits = 2)
          ) %>%
  reshape2::dcast(variable~Sampling_trip)
# Showing as table
knitr::kable(wq_mean_per_trip, caption = "Mean for all 17 physico-chemical metrics, collapsed across the four sampling trips.")

# Data needs to be in long format
wq_sd_per_trip <- reshape2::melt(wq.all.reps.for.pca[,c(1, # Reef name
                                      6:19, # All numerical vals
                                      21, # Temperature
                                      22, # Salinity
                                      23, # Fluorescence
                                      20)]) %>% # Sampling_trip
  as.data.frame() %>% 
  group_by(Sampling_trip, variable) %>% 
# Now computing mean and SD
dplyr::summarize( # This tutorial for troubleshooting! https://stackoverflow.com/questions/46661461/calculate-mean-by-group-using-dplyr-package
          sd=round(sd(value, na.rm=TRUE),
                   digits = 2)
          ) %>%
  reshape2::dcast(variable~Sampling_trip)
# Showing as table
knitr::kable(wq_sd_per_trip, caption = "SD for all 17 physico-chemical metrics, collapsed across the four sampling trips.")

# Exporting Medians as csv  
write.csv(wq_median_per_trip, file = "/home/markoterzin/Documents/PhD/Thesis/Chapter_2/Paper_drafts/the_analysis_is_finalised/Supplementary_Tables/Table_WQ_Median_per_trip.csv", quote = F, row.names = F)

# Exporting Means as csv
write.csv(wq_mean_per_trip, file = "/home/markoterzin/Documents/PhD/Thesis/Chapter_2/Paper_drafts/the_analysis_is_finalised/Supplementary_Tables/Table_WQ_mean_per_trip.csv", quote = F, row.names = F)

# Exporting SD as csv
write.csv(wq_sd_per_trip, file = "/home/markoterzin/Documents/PhD/Thesis/Chapter_2/Paper_drafts/the_analysis_is_finalised/Supplementary_Tables/Table_WQ_SD_per_trip.csv", quote = F, row.names = F)

# The csv files on median and sd values were merged manually to make the Table 1 in the main text of the manuscript
```

# Microbial metagenomic data - collection, pre-processing, and analysis

Raw counts were exported from MEGAN as biom files separately for (1) microbial taxonomy (genus level as the lowest category) and for (2) microbial functions (GO terms), and subsequently imported into R using the phyloseq R package. These biom files were combined with the metadata file to create 2 phyloseq objects (for taxa and genes), which have then undergone various filtering steps.

```{r Importing biom files and making phyloseq objects, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
### Importing the biom tables, exported from MEGAN

### Taxonomy info | at 'Genus' level
megan_genus <- import_biom("/home/markoterzin/Documents/PhD/Thesis/Chapter_2/Paper_drafts/the_analysis_is_finalised/Code/input_files/IMOS-MGD_Seawater_full_dataset_Genera_191_samples_Neg_controls_July_2024.biom")
### Functional info | GO terms
megan_GO_5 <- import_biom("/home/markoterzin/Documents/PhD/Thesis/Chapter_2/Paper_drafts/the_analysis_is_finalised/Code/input_files/IMOS-MGD_Seawater_GOs_Rank5_191_samples_Neg_controls_July_2024.biom")
# This one has 7476 GO terms
megan_GO_4 <- import_biom("/home/markoterzin/Documents/PhD/Thesis/Chapter_2/Paper_drafts/the_analysis_is_finalised/Code/input_files/IMOS-MGD_Seawater_GOs_Rank4_191_samples_Neg_controls_July_2024.biom")
# This one has 5257 GO terms
megan_GO_3 <- import_biom("/home/markoterzin/Documents/PhD/Thesis/Chapter_2/Paper_drafts/the_analysis_is_finalised/Code/input_files/IMOS-MGD_Seawater_GOs_Rank3_191_samples_Neg_controls_July_2024.biom")
# This one has 705 GO terms

# Let's just modify the metadata file a bit to include neg controls as well
metadata_neg_controls <- left_join(megan_genus@otu_table %>% 
                                     t() %>% 
                             as.data.frame() %>% 
                             rownames_to_column("Sample_ID") %>% 
                               dplyr::select("Sample_ID"),
                           metadata %>% 
                             rownames_to_column("Sample_ID")) %>% 
  column_to_rownames("Sample_ID")

# Merging:
sample_data(megan_genus) <- sample_data(metadata_neg_controls)
sample_data(megan_GO_5) <- sample_data(metadata_neg_controls)
sample_data(megan_GO_4) <- sample_data(metadata_neg_controls)
sample_data(megan_GO_3) <- sample_data(metadata_neg_controls)

# Checking the phyloseq objects
megan_genus
megan_GO_5
megan_GO_4
megan_GO_3

# But I want to filter out the PF samples, and Broomfield rep 2 (because the sequencing was repeated for this one)
megan_genus <- subset_samples(megan_genus, sample_names(megan_genus)!='Lynchs-PF-1_S107_R1' &
                                sample_names(megan_genus)!='Lynchs-PF-2_S108_R1' &
                                sample_names(megan_genus)!='Lynchs-PF-3_S109_R1' &
                                sample_names(megan_genus)!='Lynchs-PF-4_S110_R1' &
                                sample_names(megan_genus)!='Myrmidon-PF-1_S111_R1' &
                                sample_names(megan_genus)!='Myrmidon-PF-2_S112_R1' &
                                sample_names(megan_genus)!='Myrmidon-PF-3_S113_R1' &
                                sample_names(megan_genus)!='Myrmidon-PF-4_S114_R1' &
                                sample_names(megan_genus)!='Rib-PF-1_S103_R1' &
                                sample_names(megan_genus)!='Rib-PF-2_S104_R1' &
                                sample_names(megan_genus)!='Rib-PF-3_S105_R1' &
                                sample_names(megan_genus)!='Rib-PF-4_S106_R1' &
                                sample_names(megan_genus)!='Broomfield-2_S50_R1')
megan_GO_5 <- subset_samples(megan_GO_5, sample_names(megan_GO_5)!='Lynchs-PF-1_S107_R1' &
                                sample_names(megan_GO_5)!='Lynchs-PF-2_S108_R1' &
                                sample_names(megan_GO_5)!='Lynchs-PF-3_S109_R1' &
                                sample_names(megan_GO_5)!='Lynchs-PF-4_S110_R1' &
                                sample_names(megan_GO_5)!='Myrmidon-PF-1_S111_R1' &
                                sample_names(megan_GO_5)!='Myrmidon-PF-2_S112_R1' &
                                sample_names(megan_GO_5)!='Myrmidon-PF-3_S113_R1' &
                                sample_names(megan_GO_5)!='Myrmidon-PF-4_S114_R1' &
                                sample_names(megan_GO_5)!='Rib-PF-1_S103_R1' &
                                sample_names(megan_GO_5)!='Rib-PF-2_S104_R1' &
                                sample_names(megan_GO_5)!='Rib-PF-3_S105_R1' &
                                sample_names(megan_GO_5)!='Rib-PF-4_S106_R1' &
                                sample_names(megan_GO_5)!='Broomfield-2_S50_R1')
megan_GO_4 <- subset_samples(megan_GO_4, sample_names(megan_GO_4)!='Lynchs-PF-1_S107_R1' &
                                sample_names(megan_GO_4)!='Lynchs-PF-2_S108_R1' &
                                sample_names(megan_GO_4)!='Lynchs-PF-3_S109_R1' &
                                sample_names(megan_GO_4)!='Lynchs-PF-4_S110_R1' &
                                sample_names(megan_GO_4)!='Myrmidon-PF-1_S111_R1' &
                                sample_names(megan_GO_4)!='Myrmidon-PF-2_S112_R1' &
                                sample_names(megan_GO_4)!='Myrmidon-PF-3_S113_R1' &
                                sample_names(megan_GO_4)!='Myrmidon-PF-4_S114_R1' &
                                sample_names(megan_GO_4)!='Rib-PF-1_S103_R1' &
                                sample_names(megan_GO_4)!='Rib-PF-2_S104_R1' &
                                sample_names(megan_GO_4)!='Rib-PF-3_S105_R1' &
                                sample_names(megan_GO_4)!='Rib-PF-4_S106_R1' &
                                sample_names(megan_GO_4)!='Broomfield-2_S50_R1')
megan_GO_3 <- subset_samples(megan_GO_3, sample_names(megan_GO_3)!='Lynchs-PF-1_S107_R1' &
                                sample_names(megan_GO_3)!='Lynchs-PF-2_S108_R1' &
                                sample_names(megan_GO_3)!='Lynchs-PF-3_S109_R1' &
                                sample_names(megan_GO_3)!='Lynchs-PF-4_S110_R1' &
                                sample_names(megan_GO_3)!='Myrmidon-PF-1_S111_R1' &
                                sample_names(megan_GO_3)!='Myrmidon-PF-2_S112_R1' &
                                sample_names(megan_GO_3)!='Myrmidon-PF-3_S113_R1' &
                                sample_names(megan_GO_3)!='Myrmidon-PF-4_S114_R1' &
                                sample_names(megan_GO_3)!='Rib-PF-1_S103_R1' &
                                sample_names(megan_GO_3)!='Rib-PF-2_S104_R1' &
                                sample_names(megan_GO_3)!='Rib-PF-3_S105_R1' &
                                sample_names(megan_GO_3)!='Rib-PF-4_S106_R1' &
                                sample_names(megan_GO_3)!='Broomfield-2_S50_R1')

# Checking the object again
megan_genus
megan_GO_5
megan_GO_4
megan_GO_3
# These samples still include the 3 negative controls
```

## Processing data

After removing the non pre-filtered samples, further data filtering included removal of reads (1) annotated as eukaryotic or viral; and (2) rare/spurious reads. Data was then Center-Log-Ratio (hereinafter 'CLR') transformed for statistical analysis in the mixOmics R package. 

### Removal of Eukaryotic contamination

We annotated a total of 1919 microbial taxa (lowest category: genus level). Reads that were annotated as Eukarya (729 taxa in total) and viruses (11 viral annotations) were excluded from the analysis. Further analysis was performed on a phyloseq object with prokaryotic annotations only, a total of 1179 bacterial and archaeal groups (Figure 2, Table 1).

```{r Checking for Euk contamination, fig.width = 11, fig.height=19, fig.align='center', echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
# Before plotting the bar plots, I first need to prepare my objects
### Taxonomy info | at 'Genus' level
megan_genus_all <- megan_genus
megan_genus_TAX_all <- as.data.frame(megan_genus_all@tax_table)

# Plot admixture barplot - Domain level (and viruses)
cols_domain <- c(
  "d__Archaea" = "slategray3",          # Archaea
  "d__Bacteria" = "grey45",             # Bacteria
  "d__Eukaryota" = "salmon",            # Eukaryota
  "f__Mimiviridae" = "violetred",    # Family Mimiviridae
  "f__Phycodnaviridae" = "steelblue3",  # Family Phycodnaviridae
  "f__Retroviridae" = "lightsteelblue4", # Family Retroviridae
  "o__Caudovirales" = "seashell4"    # Order Caudovirales
)

DOMAIN <- as.data.frame(megan_genus_all@otu_table) %>% 
  rownames_to_column("OTUs") %>% # I will need this later to add taxonomy info
  left_join(megan_genus_TAX_all %>% rownames_to_column("OTUs")) %>% # adding taxonomy info
  column_to_rownames("OTUs") %>% 
  group_by(Rank1) %>% 
  # Keeping only numerical values now
  summarise_if(.predicate = function(x) is.numeric(x),
               .funs = funs(sum)) # Computing sums
# Now relative abundances
DOMAIN_RA <- DOMAIN
for (i in 2:(ncol(DOMAIN_RA))) {
  DOMAIN_RA[i] <- DOMAIN_RA[i] / sum(DOMAIN_RA[i]) 
}

barplots_domain <- DOMAIN_RA %>%
  column_to_rownames("Rank1") %>% 
  t() %>%
  as.data.frame() %>% 
  rownames_to_column("Sample_ID") %>% 
  reshape2::melt() %>% 
  left_join(metadata %>% rownames_to_column("Sample_ID")) %>% 
# Plotting now!
  ggplot(aes(x=Sample_ID, y=value, fill=variable))+
  geom_bar(stat = "identity")+
  scale_y_continuous(expand = c(0,0))+
  facet_wrap(~Sampling_trip, scales = "free", nrow = 5)+
#  facet_grid(~Sampling_trip, scales = "free_x", space = "free")+
  scale_fill_manual(values = cols_domain)+
  ylab("Relative abundance of taxa (at Domain level)")+
  xlab("Reef sites")+
  theme(axis.text.x = # element_blank(),
        element_text(angle = 75, hjust = 1, size = 12),
        #axis.ticks.x = element_blank(),
        #axis.title.x = element_blank(),
        strip.text = element_text(colour="black", size=12),
        panel.grid = element_blank(),
        panel.background = element_blank(),
        legend.position = "right",
        legend.title = element_blank(),
        legend.text = element_text(size = 12))
barplots_domain
```

We see that we have eukaryotic reads, let's see how many taxa?

```{r Subsetting phyloseq object to remove EUKS, , echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
megan_genus_bacteria <- subset_taxa(megan_genus, # Phyloseq object with all OTUs
                           Rank1=="d__Bacteria") # The phyloseq object with raw counts
megan_genus_archaea <- subset_taxa(megan_genus, # Phyloseq object with all OTUs
                                    Rank1=="d__Archaea") # The phyloseq object with raw counts

megan_genus_PROKS <- merge_phyloseq(megan_genus_bacteria,
                                    megan_genus_archaea) # Phyloseq object with Proks only
megan_genus_EUKS <- subset_taxa(megan_genus_all,
                          Rank1=="d__Eukaryota") # Phyloseq object with Euks only
```

```{r Table of the taxonomic breakdown, , echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
knitr::kable(as.data.frame(cbind(as.character(ntaxa(megan_genus_EUKS)), as.character(ntaxa(megan_genus_bacteria)), as.character(ntaxa(megan_genus_archaea)), as.character(ntaxa(megan_genus_PROKS)))), caption = "Taxonomic breakdown", col.names = c("Eukaryota", "Bacteria", "Archaea", "Prokarya"))
```

If we compare with abundances of prokaryotes (which are the target for this study), are there any euks that are highly abundant?

```{r Ordering all the taxa in the heatmap euks too, fig.width = 31, fig.height=36, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
megan_genus_all_with_euks <- import_biom("/home/markoterzin/Documents/PhD/Thesis/Chapter_2/Paper_drafts/the_analysis_is_finalised/Code/input_files/IMOS-MGD_Seawater_full_dataset_Genera_191_samples_Neg_controls_July_2024.biom")
# Merging!
sample_data(megan_genus_all_with_euks) <- sample_data(metadata_neg_controls)
# Removing the PF samples and Broomfield 2 (seq failed for this rep, and we have the repeated sample for rep 2)
megan_genus_all_with_euks <- subset_samples(megan_genus_all_with_euks, sample_names(megan_genus_all_with_euks)!='Lynchs-PF-1_S107_R1' &
                                sample_names(megan_genus_all_with_euks)!='Lynchs-PF-2_S108_R1' &
                                sample_names(megan_genus_all_with_euks)!='Lynchs-PF-3_S109_R1' &
                                sample_names(megan_genus_all_with_euks)!='Lynchs-PF-4_S110_R1' &
                                sample_names(megan_genus_all_with_euks)!='Myrmidon-PF-1_S111_R1' &
                                sample_names(megan_genus_all_with_euks)!='Myrmidon-PF-2_S112_R1' &
                                sample_names(megan_genus_all_with_euks)!='Myrmidon-PF-3_S113_R1' &
                                sample_names(megan_genus_all_with_euks)!='Myrmidon-PF-4_S114_R1' &
                                sample_names(megan_genus_all_with_euks)!='Rib-PF-1_S103_R1' &
                                sample_names(megan_genus_all_with_euks)!='Rib-PF-2_S104_R1' &
                                sample_names(megan_genus_all_with_euks)!='Rib-PF-3_S105_R1' &
                                sample_names(megan_genus_all_with_euks)!='Rib-PF-4_S106_R1' &
                                sample_names(megan_genus_all_with_euks)!='Broomfield-2_S50_R1')

# Removing the non-annotated stuff!
megan_genus_all_anno_only <- subset_taxa(megan_genus_all_with_euks, Rank2!="NA")
# Getting relative abundances too
megan_genus_all_RA = transform_sample_counts(megan_genus_all_with_euks, function(x) x / sum(x) )

# Selecting the top 100 most abundant MAGs (based on RA data)
megan_genus_top200_RA_abund_with_euks <- taxa_sums(megan_genus_all_RA) %>%
  sort(decreasing = TRUE) %>%
  head(200) %>% # Taking the first X most abundant taxa.
  # Change the number depending on how many Genera I want to look at
  names()

# Making a new phyloseq object
megan_genus_top200_RA_with_euks <- prune_taxa(megan_genus_top200_RA_abund_with_euks, # These are the top 20
                                  megan_genus_all_RA)

# Defining breaks - to make sure even very lowly abundant taxa will be visible!
# From Steve:
breaks=c(0,0.001,0.01,0.05,0.1,0.25,0.4,0.5,0.6,0.7,1)

# But I want to have less breaks
# breaks_5=c(0,0.001,0.1,0.3,0.7,1)
# Plot heatmap
left_join(otu_table(megan_genus_top200_RA_with_euks) %>% as.data.frame %>% rownames_to_column("OTU"),
          tax_table(megan_genus_top200_RA_with_euks) %>% as.data.frame %>% rownames_to_column("OTU")) %>%
  arrange(match(OTU, megan_genus_top200_RA_abund_with_euks)) %>% # Arranging by abundances here
  unite(taxonomy, c(OTU, Rank1, Rank2, Rank3, Rank4, Rank5, Rank6, Rank7), sep = "; ") %>% # Adding Taxonomy info
  gather(Sample_ID, Reads, -taxonomy) %>% # 'Reads' contains the Raw counts
#  left_join(as.data.frame(sample_data(megan_genus_all_RA)) %>% rownames_to_column("Sample_ID")) %>% # Now joining with the metadata
  left_join(metadata %>% rownames_to_column("Sample_ID")) %>% 
  # Ready to plot now!
  ggplot(aes(x = Sample_ID, # Short reef names on the x axis
             y = reorder(taxonomy, # Taxonomy info on the y axis
                         Reads), # With Taxa ordered based on abundances, most abundant listed first
             fill = Reads)) + # Change to 'Reads' if plotting the raw counts
  geom_tile() + # This colors the heatmap in blue & makes the more abundant taxa darker in color
  facet_grid(cols = vars(Sampling_trip), scales = "free_x", space = "free") + # Splitting in facets
  theme(axis.text.x = element_text(angle = 90, hjust = 1, size = 8)) + # Rotating the text at 90 degrees angle
  # Use this if I want a smaller number of breaks
#  scale_fill_stepsn(breaks = breaks_5, colours =c("white", # for the 0-0.001 RA range!
#                                                "slategray1", "slategray2", "slategray3", "slategray4")) +
  # Or from Steve:
  scale_fill_stepsn(breaks = breaks, colours =c("white", # for the 0-0.001 RA range!
                                                  "slategray4", # 001 - 0.01
                                                  "slategray3", # 0.01 - 0.05
                                                  "slategray2", # 0.05 - 0.1
                                                  "navajowhite", # 0.1 - 0.25
                                                  "rosybrown2", # 0.25,0.4
                                                  "lightsalmon", # 0.4 - 0.5
                                                  "rosybrown1", # 0.5 - 0.6
#                                                  "lightgoldenrod1", # 0.6 - 0.7
                                                  "indianred2")) + # 0.7,1
  scale_x_discrete(expand = c(0, 0)) +
  scale_y_discrete(expand = c(0, 0))
```

### Removal of Rare/Spurious Reads - prokaryotes only
 
Prior to removal of rare and spurious reads, non-annotated reads were removed from the dataset. We then computed relative abundance values (RA) and removed reads with average RA < 0.0001% across samples. After removing OTUs that were less than 0.0001% abundant, we retained 618 taxa (primarily at Genus level) out of the initial 1179 prokaryotic OTUs. At functional level, we retained 5015 GO annotations (out of 8689 GO terms).

```{r Setting the phyloseq object of interest - PROKS, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
### IMPORTANT - ***Change this part of the script*** depending on which phyloseq object I would like to look at: prokaryotic, eukaryotic or all. This way I wouldn't need to modify multiple lines in the script below
megan_genus <- megan_genus_PROKS # options to choose from: megan_genus_PROKS, megan_genus_EUKS

# Cleaning the names here already! This way I will make sure every other phyloseq object will have organised taxonomy
megan_genus_TAX_PROKS <- as.data.frame(megan_genus@tax_table)

# Unite the names within one column called "Taxonomy"
megan_genus_TAX_PROKS <- megan_genus_TAX_PROKS %>% 
  unite(Taxonomy, c(Rank1, Rank2, Rank3, Rank4, Rank5, Rank6, Rank7), sep = "; ") # Adding Taxonomy info

# Initialize empty columns
megan_genus_TAX_PROKS$Domain <- NA
megan_genus_TAX_PROKS$Phylum <- NA
megan_genus_TAX_PROKS$Class <- NA
megan_genus_TAX_PROKS$Order <- NA
megan_genus_TAX_PROKS$Family <- NA
megan_genus_TAX_PROKS$Genus <- NA
megan_genus_TAX_PROKS$Species <- NA

# Categorise taxonomic strings based on patterns:
megan_genus_TAX_PROKS$Domain <- str_match(megan_genus_TAX_PROKS$Taxonomy, "^d__(.+?);")[, 2]
megan_genus_TAX_PROKS$Phylum <- str_match(megan_genus_TAX_PROKS$Taxonomy, "; p__(.+?);")[, 2]
megan_genus_TAX_PROKS$Class <- str_match(megan_genus_TAX_PROKS$Taxonomy, "; c__(.+?);")[, 2]
megan_genus_TAX_PROKS$Order <- str_match(megan_genus_TAX_PROKS$Taxonomy, "; o__(.+?);")[, 2]
megan_genus_TAX_PROKS$Family <- str_match(megan_genus_TAX_PROKS$Taxonomy, "; f__(.+?);")[, 2]
megan_genus_TAX_PROKS$Genus <- str_match(megan_genus_TAX_PROKS$Taxonomy, "; g__(.+?);")[, 2]
megan_genus_TAX_PROKS$Species <- str_match(megan_genus_TAX_PROKS$Taxonomy, "; s__(.+?);")[, 2]

# Last thing: replacing missing values with "Unknown_*"
megan_genus_TAX_PROKS$Domain[is.na(megan_genus_TAX_PROKS$Domain)] <- "NA"
megan_genus_TAX_PROKS$Phylum[is.na(megan_genus_TAX_PROKS$Phylum)] <- "NA"
megan_genus_TAX_PROKS$Class[is.na(megan_genus_TAX_PROKS$Class)] <- "NA"
megan_genus_TAX_PROKS$Order[is.na(megan_genus_TAX_PROKS$Order)] <- "NA"
megan_genus_TAX_PROKS$Family[is.na(megan_genus_TAX_PROKS$Family)] <- "NA"
megan_genus_TAX_PROKS$Genus[is.na(megan_genus_TAX_PROKS$Genus)] <- "NA"
megan_genus_TAX_PROKS$Species[is.na(megan_genus_TAX_PROKS$Species)] <- "NA"

# Remove the original taxonomy column
megan_genus_TAX_PROKS <- megan_genus_TAX_PROKS %>% 
  dplyr::select(Domain, Phylum, Class, Order, Family, Genus, Species)
# All cleaned up! :) thanks ChatGPT

### Putting this back into the phyloseq object:
# First checking the current taxonomic names in phyloseq object
current_taxa_names <- taxa_names(megan_genus)
# Compare with tax_table column names and order
polished_tax_table <- colnames(t(megan_genus_TAX_PROKS))
# Check if they match
if (!identical(current_taxa_names, polished_tax_table)) {
  stop("Polished taxonomic names in megan_genus_TAX_PROKS do not match the taxa_names in the megan_genus phyloseq object.")
}
# Looks like they match! So I'm not sure why I cannot merge them (code below)

# Check dimensions of tax_table and physeq - does the number of rows match?
nrow_tax_table <- nrow(megan_genus_TAX_PROKS)
ntaxa_physeq <-ntaxa(megan_genus)  # Number of taxa in physeq

if (nrow_tax_table != ntaxa_physeq) {
  stop("Number of rows in megan_genus_TAX_PROKS does not match the number of taxa in megan_genus phyloseq object.")
}

# Step 3: Compare order of unique values
identical(megan_genus_TAX_PROKS %>% # Looking for OTU order for the polishes taxa
            rownames_to_column("OTUs") %>%
            dplyr::select("OTUs"),
          megan_genus@tax_table %>%  # Looking for OTU order in the current phyloseqq object
            as.data.frame() %>% 
            rownames_to_column("OTUs") %>% 
            dplyr::select("OTUs"))
# Again, this is also the same

# Here too:
identical(row.names(megan_genus_TAX_PROKS),
          row.names(otu_table(megan_genus))
          )
# Yes, the row names are identical

# Now adding this polished taxonomy to my phyloseq object:
tax_table(megan_genus) <- as.matrix(megan_genus_TAX_PROKS)

### Removing the negative controls too - taxa phyloseq object:
megan_genus_no_neg_control <- subset_samples(megan_genus,
                                             sample_names(megan_genus)!='Neg-control-1_S101_R1' &
                                               sample_names(megan_genus)!='Neg-control-2_S24_R1' &
                                               sample_names(megan_genus)!='Neg-control-3_S116_R1')

### Removing the negative controls too - GOs at rank 5 phyloseq object:
megan_GO_5_no_neg_control <- subset_samples(megan_GO_5,
                                             sample_names(megan_GO_5)!='Neg-control-1_S101_R1' &
                                               sample_names(megan_GO_5)!='Neg-control-2_S24_R1' &
                                               sample_names(megan_GO_5)!='Neg-control-3_S116_R1')

### Removing the negative controls too - GOs at rank 4 phyloseq object:
megan_GO_4_no_neg_control <- subset_samples(megan_GO_4,
                                             sample_names(megan_GO_4)!='Neg-control-1_S101_R1' &
                                               sample_names(megan_GO_4)!='Neg-control-2_S24_R1' &
                                               sample_names(megan_GO_4)!='Neg-control-3_S116_R1')

### Removing the negative controls too - GOs at rank 3 phyloseq object:
megan_GO_3_no_neg_control <- subset_samples(megan_GO_3,
                                             sample_names(megan_GO_3)!='Neg-control-1_S101_R1' &
                                               sample_names(megan_GO_3)!='Neg-control-2_S24_R1' &
                                               sample_names(megan_GO_3)!='Neg-control-3_S116_R1')
```

```{r Getting relative abundances, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
### Instead of setting an arbitrary threshold (e.g 100 seqs), I would like to filter based on relative abundances (***removing all OTUs < 0.0001% rel. abundance***)

# Tutorial I used: https://joey711.github.io/phyloseq/preprocess.html

### Removing reads that are annotated at Bacteria or Archaea levels only - not informative!
megan_genus_anno_only <- subset_taxa(megan_genus_no_neg_control, Phylum!="NA")

### Removing reads that were not annotated at Rank2 level - not informative!
megan_GO_5_anno_only <- subset_taxa(megan_GO_5_no_neg_control, Rank2!="NA")
megan_GO_4_anno_only <- subset_taxa(megan_GO_4_no_neg_control, Rank2!="NA")
megan_GO_3_anno_only <- subset_taxa(megan_GO_3_no_neg_control, Rank2!="NA")

# Getting the taxa data frame
megan_genus_TAX <- as.data.frame(megan_genus_anno_only@tax_table)
# Getting the taxa data frame
megan_GO_5_FUN <- as.data.frame(megan_GO_5_anno_only@tax_table)
megan_GO_4_FUN <- as.data.frame(megan_GO_4_anno_only@tax_table)
megan_GO_3_FUN <- as.data.frame(megan_GO_3_anno_only@tax_table)

### Getting the relative abundances
# Taxa
megan_genus_RA = transform_sample_counts(megan_genus_anno_only, function(x) x / sum(x) )
# GO terms
megan_GO_5_RA  = transform_sample_counts(megan_GO_5_anno_only, function(x) x / sum(x) )
megan_GO_4_RA  = transform_sample_counts(megan_GO_4_anno_only, function(x) x / sum(x) )
megan_GO_3_RA  = transform_sample_counts(megan_GO_3_anno_only, function(x) x / sum(x) )
```

```{r Removing taxa/genes below 0.0001% relative abundance, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
# removing all OTUs that are less than 0.0001% abundant
megan_genus_RA_no_rare = filter_taxa(megan_genus_RA, function(x) mean(x) > 1e-6, TRUE)
# removing all genes that are less than 0.0001% abundant
megan_GO_5_RA_no_rare = filter_taxa(megan_GO_5_RA, function(x) mean(x) > 1e-6, TRUE)
megan_GO_3_RA_no_rare = filter_taxa(megan_GO_3_RA, function(x) mean(x) > 1e-6, TRUE)
megan_GO_4_RA_no_rare = filter_taxa(megan_GO_4_RA, function(x) mean(x) > 1e-6, TRUE)
```

```{r Checking the taxonomic breakdown, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
Before_after_filtering <- cbind(rbind(ntaxa(megan_genus), ntaxa(megan_genus_RA_no_rare)),
                                rbind(ntaxa(megan_GO_5), ntaxa(megan_GO_5_RA_no_rare))
#                                rbind(ntaxa(megan_COGs), ntaxa(megan_COGs_RA_no_rare))
                                ) %>% 
  as.data.frame()
# Adding row names now
row.names(Before_after_filtering) <- c("Before filtering", "After filtering")

knitr::kable(Before_after_filtering, caption = "Removal of Rare/Spurious reads (< 0.0001% RA)", col.names = c("Taxa", "GO terms"), row.names = T)
```

```{r New phyloseq objects - keeping only the abundant taxa/genes, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
megan_genus_abundant <- prune_taxa(taxa_names(megan_genus_RA_no_rare), # List of OTUs after filtering
                                megan_genus_no_neg_control) # My phyloseq object with raw counts
megan_GO_5_abundant <- prune_taxa(taxa_names(megan_GO_5_RA_no_rare), # List of OTUs after filtering
                                megan_GO_5_no_neg_control) # My phyloseq object with raw counts
megan_GO_4_abundant <- prune_taxa(taxa_names(megan_GO_4_RA_no_rare), # List of OTUs after filtering
                                megan_GO_4_no_neg_control) # My phyloseq object with raw counts
megan_GO_3_abundant <- prune_taxa(taxa_names(megan_GO_3_RA_no_rare), # List of OTUs after filtering
                                megan_GO_3_no_neg_control) # My phyloseq object with raw counts
```

```{r Preparing for stats - CLR transformation, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
# CLR is the normalisation method suggested by the mixOmics R package for microbial data - a way to address missing values that are characteristic of microbial datasets. I need to remove missing values before doing the CLR normalisation - The geometric mean cannot be determined for sparse data without deleting, replacing or estimating the 0 count values. So I am introducing pseudo counts

### Tutorial used: http://mixomics.org/mixmc/mixmc-preprocessing/

# Checking if there are any zeros - BEFORE adding pseudocounts
sum(which(megan_genus_abundant@otu_table == 0))
sum(which(megan_GO_5_abundant@otu_table == 0))
# sum(which(megan_COGs_abundant@otu_table == 0))
# Pseudocounts - replacing all zero vals with 1; 
megan_genus_abundant@otu_table <- megan_genus_abundant@otu_table + 1
megan_GO_5_abundant@otu_table <- megan_GO_5_abundant@otu_table +1
megan_GO_3_abundant@otu_table <- megan_GO_3_abundant@otu_table +1
megan_GO_4_abundant@otu_table <- megan_GO_4_abundant@otu_table +1
# megan_COGs_abundant@otu_table <- megan_COGs_abundant@otu_table + 1
# Checking if there are any zeros - AFTER adding pseudocounts
sum(which(megan_genus_abundant@otu_table == 0))
sum(which(megan_GO_5_abundant@otu_table == 0))
# sum(which(megan_COGs_abundant@otu_table == 0))
# All good! No NAs after introducing pseudocounts

### Now I can CLR transform when running analyses in mixOmics!
# I am using an option from the microbiome R package, not the same as in MixOmics.
megan_genus_clr <- microbiome::transform(megan_genus_abundant, "clr")
megan_go_clr_5 <- microbiome::transform(megan_GO_5_abundant, "clr")
megan_go_clr_3 <- microbiome::transform(megan_GO_3_abundant, "clr")
megan_go_clr_4 <- microbiome::transform(megan_GO_4_abundant, "clr")
# megan_COGs_clr <- microbiome::transform(megan_COGs_abundant, "clr")

# megan_go_clr_3_bp <- megan_go_clr_3 %>% 
#  subset_taxa(Rank2 == 'GO:0008150 biological_process')
# megan_go_clr_4_bp <- megan_go_clr_4 %>% 
#  subset_taxa(Rank2 == 'GO:0008150 biological_process')
# But for GO at lvl 3, I only want bio process
```

```{r Saving as an R object, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
# save.image("/home/markoterzin/Documents/PhD/Thesis/Chapter_2/Paper_drafts/the_analysis_is_finalised/Code/Code_for_Terzin_et_al_Microbial_Function_Outperforms_Taxonomy_in_Inferring_Water_Chemistry_across_the_Great_Barrier_Reef.RData")
```

### ***P***rincipal ***C***omponents ***A***nalysis (***PCA***) - What are the main clustering patterns between our reefs based on physico-chemical data?

```{r PCA sample plot on taxa, fig.width = 8, fig.height=5, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE, cache=TRUE}
# Preparing the object to have taxa names on boxplots
OTUs_biplot <- as.data.frame(megan_genus_clr@otu_table) %>% 
  t() # mixOmics needs samples and microbes to be reordered, so transposing here
# Check dimensions of data
dim(OTUs_biplot)
class(OTUs_biplot)

# Getting taxa names
OTUs_biplot_colnames_for_biplot <- left_join(otu_table(megan_genus_clr) %>%
                                    as.data.frame %>%
                                    rownames_to_column("OTU"),
                                  tax_table(megan_genus_clr) %>%
                                    as.data.frame %>%
                                    rownames_to_column("OTU")) %>%
  unite(taxonomy, c(Family, Genus), sep = "; ") # Adding Taxonomy info
## Joining, by = "OTU"
OTUs_biplot_colnames_for_biplot <- OTUs_biplot_colnames_for_biplot %>% 
  dplyr::select("OTU", "taxonomy")
# Merging with the OTUs_biplot object
OTUs_biplot_names <- left_join(t(OTUs_biplot) %>% 
                           as.data.frame() %>% 
                           rownames_to_column("OTU"),
                         OTUs_biplot_colnames_for_biplot) %>% 
  unite(Annotations, c(OTU, taxonomy), sep = "_") %>% 
  column_to_rownames("Annotations") %>%  # moving this as rowposing back into the right format
  t() # trans

# PCA
result.pca.taxa.names <- pca(OTUs_biplot_names)

# Plotting the PCA sample plot
plotIndiv(result.pca.taxa.names,
          group = sample_data(megan_genus_abundant)$Sampling_trip,
          title = 'PCA | Microbial Taxonomy',
          legend = T,
          ellipse = TRUE,
          ind.names = F,
          col.per.group =c("indianred", # Sampling trip 1
                "indianred4", # Sampling trip 2 
                "red3", # Sampling trip 3
                "slateblue"), # Sampling trip 4
          legend.title = 'Sampling trip'
          )
```

```{r PCA biplot on taxa, fig.width = 13, fig.height=10, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE, cache=TRUE}
# Plotting the PCA biplot
biplot(result.pca.taxa.names,
       comp = c(1, 2),
       group = sample_data(megan_genus_abundant)$Sampling_trip,
       ind.names = F,
       ellipse = T,
       col.per.group =c("indianred", # Sampling trip 1
                        "indianred4", # Sampling trip 2
                        "red3", # Sampling trip 3
                        "slateblue"), # Sampling trip 4
       legend = TRUE,
       vline = T,
       hline = T,
       cutoff = 0.65,
       legend.title = "Sampling trip")
```

```{r PCA based on micobial taxa Tuning, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE, fig.cap="Screeplot from the PCA performed on the IMOS GBR-MGD metagenomics data (microbial taxonomy): Amount of explained variance for each principal component is shown. From the numerical output (shown bellow in tabular format), we observe that the first two principal components explain 60.31% of the total variance. The rule of thumb for choosing the number of PCA components is not so much to set a hard threshold based on the cumulative proportion of explained variance (as this is data-dependent), but to observe when a drop, or elbow, appears on the screeplot. The elbow indicates that the remaining variance is spread over many principal components and is not relevant in obtaining a low-dimensional ‘snapshot’ of the data. Based on this, we chose to keep two PCA dimensions.", fig.height=4, fig.width=6}
# Parameter tuning
tune.pca.taxa <- tune.pca(OTUs_biplot_names, ncomp = 10, scale = TRUE)
plot(tune.pca.taxa)

# Numerical output
pca.taxa.num <- pca(OTUs_biplot_names, # getting the numerical values only
                       ncomp = 10,
                       center = TRUE,
                       scale = TRUE)

# Explained variance per PCA component
knitr::kable(pca.taxa.num$prop_expl_var$X, caption = "The proportion of explained variance per each PCA component is:")
# The cumulative proportion of variance explained by each PCA component
knitr::kable(pca.taxa.num$cum.var, caption = "The cumulative proportion of variance explained by each PCA component")
```

```{r GOs_PCA_biplot, fig.width = 8, fig.height=5, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE, cache=TRUE}
# Preparing the object to have taxa names on boxplots
GOs_biplot <- as.data.frame(megan_go_clr_5@otu_table) %>% 
  t() # mixOmics needs samples and microbes to be reordered, so transposing here
# Check dimensions of data
dim(GOs_biplot)
class(GOs_biplot)

# Getting gene names
GOs_biplot_colnames_for_biplot <- left_join(otu_table(megan_go_clr_5) %>%
                                    as.data.frame %>%
                                    rownames_to_column("OTU"),
                                  tax_table(megan_go_clr_5) %>%
                                    as.data.frame %>%
                                    rownames_to_column("OTU")) %>%
  unite(Gene_annotations, c(Rank4), sep = "; ") # Adding Taxonomy info
## Joining, by = "OTU"
GOs_biplot_colnames_for_biplot <- GOs_biplot_colnames_for_biplot %>% 
  dplyr::select("OTU", "Gene_annotations")
# Merging with the OTUs_biplot object
GOs_biplot_names <- left_join(t(GOs_biplot) %>% 
                           as.data.frame() %>% 
                           rownames_to_column("OTU"),
                         GOs_biplot_colnames_for_biplot) %>% 
  unite(Annotations, c(OTU, Gene_annotations), sep = "_") %>% 
  column_to_rownames("Annotations") %>%  # moving this as rowposing back into the right format
  t() # trans

# PCA
result.pca.GOs.names <- pca(GOs_biplot_names)

# Plotting the PCA sample plot
plotIndiv(result.pca.GOs.names,
          group = sample_data(megan_GO_5_abundant)$Sampling_trip,
          title = 'PCA | Microbial Functions',
          legend = T,
          ellipse = TRUE,
          ind.names = F,
          col.per.group =c("indianred", # Sampling trip 1
                "indianred4", # Sampling trip 2 
                "red3", # Sampling trip 3
                "slateblue"), # Sampling trip 4
          legend.title = 'Sampling trip'
          )
```

```{r PCA biplot on GOs, fig.width = 13, fig.height=10, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE, cache=TRUE}
# Plotting the PCA biplot
biplot(result.pca.GOs.names,
       comp = c(1, 2),
       group = sample_data(megan_GO_5_abundant)$Sampling_trip,
       ind.names = F,
       ellipse = T,
       col.per.group =c("indianred", # Sampling trip 1
                        "indianred4", # Sampling trip 2
                        "red3", # Sampling trip 3
                        "slateblue"), # Sampling trip 4
       legend = TRUE,
       vline = T,
       hline = T,
       cutoff = 0.95,
       legend.title = "Sampling trip")
```

```{r PCA based on micobial functions Tuning, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE, fig.cap="Screeplot from the PCA performed on the IMOS GBR-MGD metagenomics data (microbial genes - GO terms): Amount of explained variance for each principal component is shown. From the numerical output (shown bellow in tabular format), we observe that the first two principal components explain 60.31% of the total variance. The rule of thumb for choosing the number of PCA components is not so much to set a hard threshold based on the cumulative proportion of explained variance (as this is data-dependent), but to observe when a drop, or elbow, appears on the screeplot. The elbow indicates that the remaining variance is spread over many principal components and is not relevant in obtaining a low-dimensional ‘snapshot’ of the data. Based on this, we chose to keep two PCA dimensions.", fig.height=4, fig.width=6}
# Parameter tuning
tune.pca.GOs <- tune.pca(GOs_biplot_names, ncomp = 10, scale = TRUE)
plot(tune.pca.GOs)

# Numerical output
pca.GOs.num <- pca(GOs_biplot_names, # getting the numerical values only
                       ncomp = 10,
                       center = TRUE,
                       scale = TRUE)

# Explained variance per PCA component
knitr::kable(pca.GOs.num$prop_expl_var$X, caption = "The proportion of explained variance per each PCA component is:")
# The cumulative proportion of variance explained by each PCA component
knitr::kable(pca.GOs.num$cum.var, caption = "The cumulative proportion of variance explained by each PCA component")
```

Parameter tuning in mixOmics to identify the optimal number of principal components (PCs) showed that the variance explained by adding more than 2 PCs is insignificant for both taxonomy and function. Hence, 2 PCs were retained. PCA clustering identified a clear difference between summer and winter samples, for both taxonomy and function. However, this clustering becomes more evident at functional compared to taxonomic levels. The percentage of variance explained by the first 2 Principal components (PCs) equaled to ~26% for taxonomy, and 55% for functions (GO terms). A PERMANOVA test was then carried out to investigate which comparisons are statistically significant.

### PERMANOVA

Analysis of similarities (ANOSIM) testing whether there is a statistically significant difference between two or more groups of sampling units - sampling trips. We will then perform a Pairwise PERMANOVA.

```{r PERMANOVA - Taxa, fig.width = 33, fig.height=8, fig.align='center', echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
taxa.anosim <- left_join(otu_table(megan_genus_RA_no_rare) %>%
                           as.data.frame %>%
                           rownames_to_column("OTU"),
                         megan_genus_TAX %>%
                           rownames_to_column("OTU")) %>% 
  unite(taxonomy, c(OTU, Domain, Phylum, Class, Order, Family, Genus, Species), sep = "; ") %>% 
  column_to_rownames("taxonomy")
# Removing rows with NAs, because ANOSIM does not take in missing vals
taxa.anosim <- na.omit(taxa.anosim)

# Object is ready to perform the test
ano_taxa <- anosim(t(taxa.anosim), 
                   sample_data(megan_genus_RA_no_rare)$Sampling_trip, 
                   distance = "bray", 
                   permutations = 9999)
# Results
ano_taxa
```

Pairwise PERMANOVA - taxa

### Visualisation

Phylum level

### What are ***the most abundant phyla?***

Out of the 29 bacterial and archaeal phyla we identified, the most abundant phyla were Cyanobacteria, Proteobacteria, and Bacteroidetes, respectively. Bacteroidetes increased in abundance for those samples collected during the peak of summer (February 2020), and were lowest in abundances during winter (July 2020).

```{r Phylum breakdown, fig.width = 8, fig.height=9, fig.align='center', warning=FALSE, echo=TRUE, eval=TRUE, fig.width = 15, fig.height=15}

# Before plotting the bar plots, I first need to prepare my objects
taxa.barplots_phylum <- left_join(otu_table(megan_genus_abundant) %>%
                                    as.data.frame %>%
                                    rownames_to_column("OTU"),
                                  tax_table(megan_genus_abundant) %>%
                                    as.data.frame %>%
                                    rownames_to_column("OTU"))

# Now setting OTUs as row names
rownames(taxa.barplots_phylum) <- taxa.barplots_phylum[,1]
taxa.barplots_phylum[,1] <- NULL

# Now summarising raw counts at phylum level
taxa.barplots_phylum.sum <- ddply(taxa.barplots_phylum, "Phylum", numcolwise(sum))

# Ready to compute raw abundances per sample - by dividing cell value with column sum
taxa.barplots_phylum.sum_RA <- taxa.barplots_phylum.sum
for (i in 2:(ncol(taxa.barplots_phylum.sum))) { # '2:' as the first column is not numeric
  taxa.barplots_phylum.sum_RA[i] <- taxa.barplots_phylum.sum_RA[i] / sum(taxa.barplots_phylum.sum_RA[i]) 
}
# taxa.barplots_phylum.sum_RA

# Now setting row names - RA
taxa.barplots_phylum.sum_RA <- taxa.barplots_phylum.sum_RA %>% remove_rownames %>% column_to_rownames(var="Phylum")
taxa.barplots_phylum_transposed_RA <- t(taxa.barplots_phylum.sum_RA)

# Now setting back the col names before melting - RA
taxa.barplots_phylum_transposed_RA <- tibble::rownames_to_column(as.data.frame(taxa.barplots_phylum_transposed_RA), "Sample_ID")
taxa.barplots_phylum_transposed_melt_RA = reshape2::melt(taxa.barplots_phylum_transposed_RA, id.vars=c("Sample_ID"))

# At last, we add metadata_barplots info so that I can make facets in the plot - RA
taxa.barplots_phylum_transposed_melt_RA <- left_join(taxa.barplots_phylum_transposed_melt_RA,
                                                     metadata %>% rownames_to_column("Sample_ID"))

# Setting colors - hardcoding!
cols_phyla <- c(
  "Acidobacteria" = "skyblue2",                      # Acidobacteria
  "Actinobacteria" = "slateblue4",                   # Actinobacteria
  "Bacteroidetes" = "salmon1",                       # Bacteroidetes
  "Balneolaeota" = "plum2",                          # Balneolaeota
  "Candidatus Kaiserbacteria" = "skyblue1",          # Candidatus Kaiserbacteria
  "Candidatus Marinimicrobia" = "slategray4",        # Candidatus Marinimicrobia
  "Candidatus Peregrinibacteria" = "lavenderblush3", # Candidatus Peregrinibacteria
  "Candidatus Tectomicrobia" = "tomato1",            # Candidatus Tectomicrobia
  "Candidatus Thermoplasmatota" = "lightgoldenrod1", # Candidatus Thermoplasmatota
  "Chlamydiae" = "olivedrab",                        # Chlamydiae
  "Chlorobi" = "seagreen3",                          # Chlorobi
  "Chloroflexi" = "slateblue3",                      # Chloroflexi
  "Cyanobacteria" = "darkseagreen3",                 # Cyanobacteria
  "Deinococcus-Thermus" = "rosybrown4",              # Deinococcus-Thermus
  "Euryarchaeota" = "violetred1",                    # Euryarchaeota
  "Fibrobacteres" = "navajowhite2",                  # Fibrobacteres
  "Firmicutes" = "indianred",                        # Firmicutes
  "Fusobacteria" = "skyblue3",                       # Fusobacteria
  "Gemmatimonadetes" = "tomato2",                    # Gemmatimonadetes
  "Lentisphaerae" = "lightyellow",                   # Lentisphaerae
  "Nitrospinae" = "khaki",                           # Nitrospinae
  "Nitrospirae" = "rosybrown",                       # Nitrospirae
  "Planctomycetes" = "mediumpurple1",                # Planctomycetes
  "Proteobacteria" = "lightblue",                    # Proteobacteria
  "Rhodothermaeota" = "tomato3",                     # Rhodothermaeota
  "Spirochaetes" = "wheat1",                         # Spirochaetes
  "Tenericutes" = "palegoldenrod",                   # Tenericutes
  "Thaumarchaeota" = "plum4",                        # Thaumarchaeota
  "Verrucomicrobia" = "tan1"                        # Verrucomicrobia
)

# Ready to plot
ggplot(data=taxa.barplots_phylum_transposed_melt_RA,
                                 aes(x=Sample_ID,
                                     y=value,
                                     fill=variable))+
  geom_bar(stat = "identity")+
  scale_y_continuous(expand = c(0,0))+
  facet_wrap(~Sampling_trip, scales = "free", nrow = 4)+
#  scale_fill_manual(values = cols)+
#  facet_wrap(~Sampling_trip, scales = "free", nrow = 4)+
#  facet_grid(~Sampling_trip, scales = "free_x", space = "free")+
  scale_fill_manual(values = cols_phyla)+
  ylab("Relative abundance of taxa (at Phylum level)")+
  xlab("Reef sites")+
  theme(axis.text.x = element_text(angle = 75, hjust = 1, size = 12),
        #axis.ticks.x = element_blank(),
        #axis.title.x = element_blank(),
        strip.text = element_text(colour="black", size=12),
        panel.grid = element_blank(),
        panel.background = element_blank(),
        legend.position = "right",
        legend.title = element_blank(),
        legend.text = element_text(size = 12))
# ggarrange(admix.bar_data, admix.bar_data_RA,
#          ncol = 1, nrow = 2)
```

```{r Average rel abundances for phyla including unknown across all sites, fig.width = 16, fig.height=21, fig.align='center', warning=FALSE, echo=TRUE, eval=TRUE}
# Group by mean using R Base aggregate()
phylum_mean <- aggregate(taxa.barplots_phylum_transposed_melt_RA$value, by=list(taxa.barplots_phylum_transposed_melt_RA$variable), FUN=mean)
# Checking that the row sums will be 1
sum(phylum_mean$x)
# It worked

# Printing as table now, by sorting the values too.
knitr::kable(arrange(phylum_mean, desc(x)), caption = "Mean relative abundances at Phylum level, across all samples. We observe that 47.27% of the reads cannot be annotated bellow the Phylum level.")
```

```{r Known phyla breakdown, fig.width = 8, fig.height=9, fig.align='center', warning=FALSE, echo=TRUE, eval=TRUE, fig.width = 15, fig.height=15}
OTUs_non_annotated_phyla_to_remove <- c("1869227", "2", "2157")
megan_genus_abundant_known_phyla_only <- subset_taxa(megan_genus_abundant,
                                                     !taxa_names(megan_genus_abundant) %in% OTUs_non_annotated_phyla_to_remove)
# Before plotting the bar plots, I first need to prepare my objects
taxa.barplots_phylum_known <- left_join(otu_table(megan_genus_abundant_known_phyla_only) %>%
                                    as.data.frame %>%
                                    rownames_to_column("OTU"),
                                  tax_table(megan_genus_abundant_known_phyla_only) %>%
                                    as.data.frame() %>% 
                                    rownames_to_column("OTU")) %>% 
  column_to_rownames("OTU")

# Now summarising raw counts at phylum level
taxa.barplots_phylum_known.sum <- ddply(taxa.barplots_phylum_known, "Phylum", numcolwise(sum))

# Ready to compute raw abundances per sample - by dividing cell value with column sum
taxa.barplots_phylum_known.sum_RA <- taxa.barplots_phylum_known.sum
for (i in 2:(ncol(taxa.barplots_phylum_known.sum))) { # '2:' as the first column is not numeric
  taxa.barplots_phylum_known.sum_RA[i] <- taxa.barplots_phylum_known.sum_RA[i] / sum(taxa.barplots_phylum_known.sum_RA[i]) 
}
# taxa.barplots_phylum.sum_RA

# Now setting row names - RA
taxa.barplots_phylum_known.sum_RA <- taxa.barplots_phylum_known.sum_RA %>% remove_rownames %>% column_to_rownames(var="Phylum")
taxa.barplots_phylum_known_transposed_RA <- t(taxa.barplots_phylum_known.sum_RA)

# Now setting back the col names before melting - RA
taxa.barplots_phylum_known_transposed_RA <- tibble::rownames_to_column(as.data.frame(taxa.barplots_phylum_known_transposed_RA), "Sample_ID")
taxa.barplots_phylum_known_transposed_melt_RA = reshape2::melt(taxa.barplots_phylum_known_transposed_RA, id.vars=c("Sample_ID"))

# At last, we add metadata_barplots info so that I can make facets in the plot - RA
taxa.barplots_phylum_known_transposed_melt_RA <- left_join(taxa.barplots_phylum_known_transposed_melt_RA,
                                                     metadata %>% rownames_to_column("Sample_ID"))

# Setting colors - hardcoding!
cols_phyla_known <- c(
  "Acidobacteria" = "skyblue2",                      # Acidobacteria
  "Actinobacteria" = "slateblue4",                   # Actinobacteria
  "Bacteroidetes" = "salmon1",                       # Bacteroidetes
  "Balneolaeota" = "plum2",                          # Balneolaeota
  "Candidatus Kaiserbacteria" = "skyblue1",          # Candidatus Kaiserbacteria
  "Candidatus Marinimicrobia" = "slategray4",        # Candidatus Marinimicrobia
  "Candidatus Peregrinibacteria" = "lavenderblush3", # Candidatus Peregrinibacteria
  "Candidatus Tectomicrobia" = "tomato1",            # Candidatus Tectomicrobia
  "Candidatus Thermoplasmatota" = "lightgoldenrod1", # Candidatus Thermoplasmatota
  "Chlamydiae" = "olivedrab",                        # Chlamydiae
  "Chlorobi" = "seagreen3",                          # Chlorobi
  "Chloroflexi" = "slateblue3",                      # Chloroflexi
  "Cyanobacteria" = "darkseagreen3",                 # Cyanobacteria
  "Deinococcus-Thermus" = "rosybrown4",              # Deinococcus-Thermus
  "Euryarchaeota" = "violetred1",                    # Euryarchaeota
  "Fibrobacteres" = "navajowhite2",                  # Fibrobacteres
  "Firmicutes" = "indianred",                        # Firmicutes
  "Fusobacteria" = "skyblue3",                       # Fusobacteria
  "Gemmatimonadetes" = "tomato2",                    # Gemmatimonadetes
  "Lentisphaerae" = "lightyellow",                   # Lentisphaerae
  "Nitrospinae" = "khaki",                           # Nitrospinae
  "Nitrospirae" = "rosybrown",                       # Nitrospirae
  "Planctomycetes" = "mediumpurple1",                # Planctomycetes
  "Proteobacteria" = "lightblue",                    # Proteobacteria
  "Rhodothermaeota" = "tomato3",                     # Rhodothermaeota
  "Spirochaetes" = "wheat1",                         # Spirochaetes
  "Tenericutes" = "palegoldenrod",                   # Tenericutes
  "Thaumarchaeota" = "plum4",                        # Thaumarchaeota
  "Verrucomicrobia" = "tan1"                        # Verrucomicrobia
)

# Ready to plot
ggplot(data=taxa.barplots_phylum_known_transposed_melt_RA,
                                 aes(x=Sample_ID,
                                     y=value,
                                     fill=variable))+
  geom_bar(stat = "identity")+
  scale_y_continuous(expand = c(0,0))+
  facet_wrap(~Sampling_trip, scales = "free", nrow = 4)+
#  scale_fill_manual(values = cols)+
#  facet_wrap(~Sampling_trip, scales = "free", nrow = 4)+
#  facet_grid(~Sampling_trip, scales = "free_x", space = "free")+
  scale_fill_manual(values = cols_phyla_known)+
  ylab("Relative abundance of taxa (at Phylum level)")+
  xlab("Reef sites")+
  theme(axis.text.x = element_text(angle = 75, hjust = 1, size = 12),
        #axis.ticks.x = element_blank(),
        #axis.title.x = element_blank(),
        strip.text = element_text(colour="black", size=12),
        panel.grid = element_blank(),
        panel.background = element_blank(),
        legend.position = "right",
        legend.title = element_blank(),
        legend.text = element_text(size = 12))
# ggarrange(admix.bar_data, admix.bar_data_RA,
#          ncol = 1, nrow = 2)
```

```{r Average rel abundances for phyla within trips, fig.width = 16, fig.height=21, fig.align='center', warning=FALSE, echo=TRUE, eval=TRUE}
# Group by mean using R Base aggregate()
phylum_mean_per_trip <- aggregate(taxa.barplots_phylum_known_transposed_melt_RA$value, by=list(taxa.barplots_phylum_known_transposed_melt_RA$variable, taxa.barplots_phylum_known_transposed_melt_RA$Sampling_trip),
                                  FUN=mean)
# Checking that the row sums will be 1
sum(phylum_mean_per_trip$x)
# It worked

knitr::kable(dcast(phylum_mean_per_trip, Group.1 ~ Group.2, value.var = "x"), caption = "Mean relative abundances at Phylum level, partitioned per trip.")
```

```{r The top 20 most abundant genera, fig.width = 16, fig.height=21, fig.align='center', warning=FALSE, eval=TRUE, echo=TRUE}
# Before plotting the bar plots, I first need to prepare my objects
counts_collapsed_genera <- left_join(otu_table(megan_genus_abundant_known_phyla_only) %>%
                                          as.data.frame %>%
                                          rownames_to_column("OTU"),
                                        tax_table(megan_genus_abundant_known_phyla_only) %>%
                                          as.data.frame %>% 
                                          rownames_to_column("OTU")) %>% 
  column_to_rownames("OTU")

# Now summarising raw counts at Genus (?) level
# taxa.barplots_top20_genera.sum_1 <- ddply(taxa.barplots_top20_genera, "Rank7", numcolwise(sum))
counts_collapsed_genera.sum <- ddply(counts_collapsed_genera, "Genus", numcolwise(sum)) %>% 
  column_to_rownames("Genus")

# ------------------------------------------- #
# Now finding the top 20 most abundant genera #
# ------------------------------------------- #

# Let's calculate the average Genus counts across all samples (Genus is in rows)
counts_collapsed_genera.sum$avg_value <- rowMeans(counts_collapsed_genera.sum)

# Order rows based on average value in descending order
counts_collapsed_genera.sum <- counts_collapsed_genera.sum[order(counts_collapsed_genera.sum$avg_value, decreasing = TRUE), ]
# Remove the avg_value column now - I don't need it anymore
counts_collapsed_genera.sum$avg_value <- NULL
# Now move the Unknown Genus row at the end
row_index <- which(rownames(counts_collapsed_genera.sum) == "NA")
# Move the identified row to the end of the data frame
counts_collapsed_genera.sum <- rbind(counts_collapsed_genera.sum[-row_index, ],
                                     counts_collapsed_genera.sum[row_index, ]
                                     )

# Now collapsing all values bellow the top 20 most abundant genera into "Other"
counts_collapsed_genera.sum.Others <- counts_collapsed_genera.sum
counts_collapsed_genera.sum.Others_top <- slice(counts_collapsed_genera.sum.Others, 1:20)
counts_collapsed_genera.sum.Others_bottom <- slice(counts_collapsed_genera.sum.Others, 21:n())

# Summarise rows from the 21st onwards into one summary row
summary_row <- colSums(counts_collapsed_genera.sum.Others_bottom[, sapply(counts_collapsed_genera.sum.Others_bottom, is.numeric)]) %>% 
  as.data.frame() %>% 
  t()
rownames(summary_row) <- "Other"

# Combine the top 20 rows with the summary row containing all other taxa (including those with "Unknown Genus")
counts_collapsed_genera.sum_21 <- rbind(counts_collapsed_genera.sum.Others_top, summary_row)

# Ready to compute raw abundances per sample - by dividing cell value with column sum
taxa.barplots_top20_genera.sum_RA <- counts_collapsed_genera.sum_21
for (i in 1:(ncol(counts_collapsed_genera.sum_21))) {
  taxa.barplots_top20_genera.sum_RA[i] <- taxa.barplots_top20_genera.sum_RA[i] / sum(taxa.barplots_top20_genera.sum_RA[i]) 
}
taxa.barplots_top20_genera.sum_RA
# Checking that it sums up to 1
colSums(taxa.barplots_top20_genera.sum_RA)

# Now setting row names - RA
taxa.barplots_top20_genera_transposed_RA <- t(taxa.barplots_top20_genera.sum_RA)

# Now setting back the col names before melting - RA
taxa.barplots_top20_genera_transposed_RA <- tibble::rownames_to_column(as.data.frame(taxa.barplots_top20_genera_transposed_RA), "Sample_ID")
taxa.barplots_top20_genera_transposed_melt_RA = reshape2::melt(taxa.barplots_top20_genera_transposed_RA, id.vars=c("Sample_ID"))

# At last, we add metadata_barplots info so that I can make facets in the plot - RA
taxa.barplots_top20_genera_transposed_melt_RA <- left_join(taxa.barplots_top20_genera_transposed_melt_RA,
                                                           metadata %>% 
                                                             rownames_to_column("Sample_ID"))

# Setting colors
cols_top20_genera <- c(
  "Synechococcus" = "seagreen",
  "Candidatus Pelagibacter" = "steelblue4",
  "Prochlorococcus" = "palegreen3",
  "Candidatus Actinomarina" = "powderblue",
  "Candidatus Puniceispirillum" = "seashell2",
  "Cyanobium" = "seagreen2",
  "Marinovum" = "olivedrab1",
  "Luminiphilus" = "maroon",
  "Pseudomonas" = "grey45",
  "Polaribacter" = "salmon",
  "Rhodopirellula" = "tan",
  "Flavobacterium" = "indianred4",
  "Litoricola" = "turquoise",
  "Vibrio" = "indianred3",
  "Balneola" = "seagreen3",
  "Erythrobacter" = "plum4",
  "Pseudoalteromonas" = "slategrey",
  "Sulfitobacter" = "plum",
  "Nisaea" = "steelblue3",
  "Candidatus Endolissoclinum" = "tan2",
  "Other" = "snow3"
)

admix_top20_genera_RA=ggplot(data=taxa.barplots_top20_genera_transposed_melt_RA,
                        aes(x=Sample_ID,
                            y=value,
                            fill=variable))+
  geom_bar(stat = "identity")+
  scale_y_continuous(expand = c(0,0))+
  facet_wrap(~Sampling_trip, scales = "free", nrow = 4)+
#    facet_wrap(~Sampling_trip, scales = "free", ncol = 1, nrow = 4)+
#  facet_grid(~Sampling_trip, scales = "free_x", space = "free")+
  scale_fill_manual(values = cols_top20_genera)+
  ylab("Relative abundances of taxa (at 'Genus' level)")+
  xlab("Reef sites")+
  theme(axis.text.x = element_text(angle = 75, hjust = 1, size = 12),
        #axis.ticks.x = element_blank(),
        #axis.title.x = element_blank(),
        strip.text = element_text(colour="black", size=12),
        panel.grid = element_blank(),
        panel.background = element_blank(),
        legend.position = "right",
        legend.title = element_blank(),
        legend.text = element_text(size = 12))
admix_top20_genera_RA
```

```{r Average rel abundances for genera, fig.width = 16, fig.height=21, fig.align='center', warning=FALSE, echo=TRUE, eval=TRUE}
# Group by mean using R Base aggregate()
genera_mean <- aggregate(taxa.barplots_top20_genera_transposed_melt_RA$value, by=list(taxa.barplots_top20_genera_transposed_melt_RA$variable), FUN=mean)
# Checking that the row sums will be 1
sum(genera_mean$x)
# It worked

# Printing as table now, by sorting the values too.
knitr::kable(arrange(genera_mean, desc(x)), caption = "Mean relative abundances at Genus level, across all samples. We only show the balue for the top 20 most abundant genera, and values for all others are collapsed within the category Other, shown in grey on the barplots.")
```

```{r Average rel abundances for genera within trips, fig.width = 16, fig.height=21, fig.align='center', warning=FALSE, echo=TRUE, eval=TRUE}
# Group by mean using R Base aggregate()
genera_mean_per_trip <- aggregate(taxa.barplots_top20_genera_transposed_melt_RA$value, by=list(taxa.barplots_top20_genera_transposed_melt_RA$variable, taxa.barplots_top20_genera_transposed_melt_RA$Sampling_trip), FUN=mean)
# Checking that the row sums will be 1
sum(genera_mean_per_trip$x)
# It worked

knitr::kable(dcast(genera_mean_per_trip, Group.1 ~ Group.2, value.var = "x"), caption = "Mean relative abundances at Genus level, partitioned per trip.")
```

```{r Bacteroidetes diversity within trips plottinig medians, fig.height=9, fig.width=9, fig.align='center', fig.cap="Bacteroidetes Shannon index", eval=TRUE, message = FALSE, warning=FALSE, echo=TRUE}
# Subsetting my phyloseq object - I only want Bacteroidetes!
megan_Bacteroidetes <- subset_taxa(megan_genus_abundant, # Phyloseq object with all OTUs
                           Phylum=="Bacteroidetes") # The phyloseq object with raw counts

# Shannon diversity
megan_genus_shannon_Bacteroidetes <- diversity(t(otu_table(megan_Bacteroidetes)), index = "shannon")

# Preparing the objects to visualise as boxplots
# Shannon
megan_genus_shannon_boxplots_Bacteroidetes <- as.data.frame(megan_genus_shannon_Bacteroidetes)
megan_genus_shannon_boxplots_Bacteroidetes <- tibble::rownames_to_column(megan_genus_shannon_boxplots_Bacteroidetes, "Sample_ID")
megan_genus_shannon_boxplots_Bacteroidetes <- left_join(megan_genus_shannon_boxplots_Bacteroidetes,
                                                        metadata %>%
                                                          rownames_to_column("Sample_ID"))

# Getting median and SD: https://stackoverflow.com/questions/13372734/how-to-display-the-median-value-in-a-faceted-boxplot-in-ggplot
Shannon_numerical_summ_Bacteroidetes <- ddply(megan_genus_shannon_boxplots_Bacteroidetes,
                                              .(Sampling_trip),
                                              summarize,
                                              med = median(megan_genus_shannon_Bacteroidetes),
                                              SD = sd(megan_genus_shannon_Bacteroidetes))

# Plotting
ggplot(megan_genus_shannon_boxplots_Bacteroidetes, aes(y = megan_genus_shannon_Bacteroidetes, x = Sampling_trip)) + # Shannon index
  geom_boxplot(aes(fill=factor(Sampling_trip)), outlier.shape = NA) +
  geom_jitter(size=1.2, alpha=0.5) + # adding actual data points
  geom_text(data = Shannon_numerical_summ_Bacteroidetes, aes(y = med, label = round(med,2)),size = 4.5, vjust = -0.5) + # adding median as text
  geom_text(data = Shannon_numerical_summ_Bacteroidetes, aes(y = SD, label = round(SD,2)),size = 4.5, vjust = -0.5) + # adding median as text
  scale_fill_manual(values=c("indianred", # Sampling trip 1
                                "indianred4", # Sampling trip 2 
                                "red3", # Sampling trip 3
                                "slateblue")) + # Sampling trip 4
  coord_flip()+ # just flipping the plot
  labs(title="Alpha diversity - within Bacteroidetes", 
       subtitle="Across sampling trips",
       x="Sampling events",
       y="Shannon index")+
  theme(axis.text.x = element_text(angle = 90, hjust = 1, size = 12)) +
  theme_bw() +
  ylim(1,5) +
  stat_pvalue_manual(megan_genus_shannon_boxplots_Bacteroidetes %>% 
                       pairwise_wilcox_test(megan_genus_shannon_Bacteroidetes ~ Sampling_trip) %>% 
                       add_xy_position())
# I will modify this manually in Inkscape
```

```{r Bacteroidetes diversity per trip median and SD values as numerical, fig.height=5, fig.width=9, fig.align='center', fig.cap="Bacteroidetes Shannon index", eval=TRUE, message = FALSE, warning=FALSE, echo=FALSE}
knitr::kable(Shannon_numerical_summ_Bacteroidetes, caption = "Median and standard deviation for Shannon Index values within Bacteroidetes, computed within trips.")
```

```{r Bacteroidetes diversity within trips Numerical output, eval=TRUE, message = FALSE, warning=FALSE, echo=TRUE}
# Numerical output
knitr::kable(megan_genus_shannon_boxplots_Bacteroidetes %>% 
                       pairwise_wilcox_test(megan_genus_shannon_Bacteroidetes ~ Sampling_trip),
             caption = "Wilcoxon rank sum test to compare median Shanon Diversity between trips, computed within Bacteroidetes.")
```


```{r Barplots only within Bacteroidetes, fig.width = 22, fig.height=21, fig.align='center', message=FALSE, warning=FALSE, eval=TRUE, echo=FALSE}
# Before plotting the bar plots, I first need to prepare my objects
taxa.barplots_Bacteroidetes_genus <- left_join(otu_table(megan_genus_abundant) %>%
                                                 as.data.frame %>%
                                                 rownames_to_column("OTU"),
                                               tax_table(megan_genus_abundant) %>%
                                                 as.data.frame %>%
                                                 rownames_to_column("OTU")
                                               )

# Keeping only Bacteroidetes
taxa.barplots_Bacteroidetes_genus <- filter(taxa.barplots_Bacteroidetes_genus,
                                            grepl("Bacteroidetes", Phylum)) %>% 
  column_to_rownames("OTU")

# Removing all missing values
# taxa.barplots_Bacteroidetes_genus <- na.omit(taxa.barplots_Bacteroidetes_genus)
# Now trying to sumarise counts within genus level
taxa.barplots_Bacteroidetes_genus.sum <- ddply(taxa.barplots_Bacteroidetes_genus, "Genus", numcolwise(sum))
# Remove Unknown

unknown_bacteroidetes <- "NA"
taxa.barplots_Bacteroidetes_genus.sum <- taxa.barplots_Bacteroidetes_genus.sum %>% 
  filter(Genus != unknown_bacteroidetes)

# Ready to compute raw abundances per sample - by dividing cell value with column sum
taxa.barplots_Bacteroidetes_genus.sum_RA <- taxa.barplots_Bacteroidetes_genus.sum
for (i in 2:(ncol(taxa.barplots_Bacteroidetes_genus.sum))) {
  taxa.barplots_Bacteroidetes_genus.sum_RA[i] <- taxa.barplots_Bacteroidetes_genus.sum_RA[i] / sum(taxa.barplots_Bacteroidetes_genus.sum_RA[i])
}
# taxa.barplots_Bacteroidetes_genus.sum_RA

# Now setting row names
taxa.barplots_Bacteroidetes_genus.sum_RA <- taxa.barplots_Bacteroidetes_genus.sum_RA %>% remove_rownames %>% column_to_rownames(var="Genus")
taxa.barplots_Bacteroidetes_genus_transposed_RA <- t(taxa.barplots_Bacteroidetes_genus.sum_RA)
# Now setting back the col names before melting
taxa.barplots_Bacteroidetes_genus_transposed_RA <- tibble::rownames_to_column(as.data.frame(taxa.barplots_Bacteroidetes_genus_transposed_RA), "Sample_ID")
taxa.barplots_Bacteroidetes_genus_transposed_melt_RA = reshape2::melt(taxa.barplots_Bacteroidetes_genus_transposed_RA, id.vars=c("Sample_ID"))
# Looks like it worked!

# At last, now we add metadata_barplots info so that I can make facets in the plot
taxa.barplots_Bacteroidetes_genus_transposed_melt_RA <- left_join(taxa.barplots_Bacteroidetes_genus_transposed_melt_RA,
                                                                  metadata %>% 
                                                                    rownames_to_column("Sample_ID"))

# Plotting
cols_Bacteroidetes_genus <- c("lemonchiffon", # g__Aequorivita
                              "rosybrown", # g__Algibacter
                              "indianred", # g__Algoriphagus
                              "lightsalmon", # g__Alistipes
                              "khaki4", # g__Aquimarina
                              "hotpink3", # g__Arenibacter
                              # "plum", # g__Aureicoccus
                              "rosybrown1", # g__Aureispira
                              "mistyrose", # g__Bacteroides
                              "lemonchiffon1", # g__Bizionia
                              #"khaki2", # g__Candidatus Amoebophilus
                              "rosybrown4", # g__Capnocytophaga
                              "mediumpurple", # g__Cellulophaga
                              "hotpink4", # g__Chitinophaga
                              "lemonchiffon3", # g__Chryseobacterium
                              "khaki1", # g__Croceitalea
                              "slategray4", # g__Crocinitomix
                              "royalblue4", # g__Dokdonia
                              "lemonchiffon2", # g__Draconibacterium
                              "mediumpurple1", # g__Ekhidna
                              "slategrey", # g__Eudoraea
                              "royalblue3", # g__Flagellimonas
                              "lemonchiffon4", # g__Flammeovirga
                              "mediumpurple3", # g__Flavicella
                              "slategray3", # g__Flavobacterium
                              "royalblue", # g__Fluviicola
                              "rosybrown2", # g__Formosa
                              "slategray", # g__Fulvivirga
                              "hotpink2", # g__Gaetbulibacter
                              "khaki3", # g__Galbibacter
                              "royalblue1", # g__Gelidibacter
                              "slategray2", # g__Gillisia
                              "mediumpurple2", # g__Gilvibacter
                              "seagreen2", # g__Gramella
                              "palegreen4", # g__Hymenobacter
                              "seagreen", # g__Hyunsoonleella
                              "royalblue2", # g__Jejuia
                              "slategray1", # g__Kordia
                              "peachpuff2", # g__Lacinutrix
                              "palegreen1", # g__Leeuwenhoekiella
                              "mistyrose3", # g__Leptobacterium
                              "tan2", # g__Lewinella
                              "peachpuff3", # g__Lutibacter
                              "peachpuff4", # g__Mangrovimonas
                              "mistyrose1", # g__Maribacter
                              "mediumpurple4", # g__Marinifilum
                              "mistyrose2", # g__Marinoscillum
                              "grey", # g__Mesoflavibacter
                              "tan1", # g__Mesonia
                              "seagreen3", # g__Mucilaginibacter
                              "tan", # g__Muricauda
                              "palegreen3", # g__Muriicola
                              "khaki", # g__Myroides
                              "lightblue3", # g__Nonlabens
                              "lightyellow1", # g__Olleya
                              "lightsteelblue2", # g__Pedobacter
                              "salmon1", # g__Phaeodactylibacter
                              "seagreen3", # g__Polaribacter
                              "mistyrose4", # g__Prevotella
                              "lightsteelblue3", # g__Pricia
                              "lightyellow", # g__Psychroflexus
                              "peachpuff1", # g__Psychroserpens
                              "grey", # g__Reichenbachiella
                              "lightsteelblue1", # g__Robertkochia
                              "palevioletred2", # g__Robiginitalea
                              "lightblue2", # g__Roseivirga
                              "palegreen", # g__Salegentibacter
                              "lightsteelblue", # g__Salinimicrobium
                              "lightblue4", # g__Sediminicola
                              "lightyellow3", # g__Seonamhaeicola
                              "palegreen1", # g__Sinomicrobium
                              "lightblue1", # g__Sphingobacterium
                              "lightyellow2", # g__Tamlana
                              "palevioletred", # g__Tenacibaculum
                              "palevioletred3", # g__Wenyingzhuangia
                              "lightblue", # g__Winogradskyella
                              "palevioletred4", # g__Xanthomarina
                              "palevioletred1", # g__Zobellia
                              "plum4") # g__Zunongwangia
# "peru", # o__Bacteroidetes genus II. Incertae sedis
# "snow3") # No hits
# "snow3") # No hits

# Relative abundances
admix_Bacteroidetes_RA=ggplot(data=taxa.barplots_Bacteroidetes_genus_transposed_melt_RA,
                              aes(x=Sample_ID,
                                  y=value,
                                  fill=variable))+
  geom_bar(stat = "identity")+
  scale_y_continuous(expand = c(0,0))+
  facet_wrap(~Sampling_trip, scales = "free", nrow = 4)+
# facet_grid(~Sampling_trip, scales = "free_x", space = "free")+
  scale_fill_manual(values = cols_Bacteroidetes_genus)+
  ylab("BACTEROIDETES | Relative abundances of taxa (at 'Genus' level)")+
  xlab("Reef sites")+
  theme(axis.text.x = element_text(angle = 75, hjust = 1, size = 12),
        #axis.ticks.x = element_blank(),
        #axis.title.x = element_blank(),
        strip.text = element_text(colour="black", size=12),
        panel.grid = element_blank(),
        panel.background = element_blank(),
        legend.position = "right",
        legend.title = element_blank(),
        legend.text = element_text(size = 12))
admix_Bacteroidetes_RA
```

Does diversity differ across trips when computed on overall communities?

```{r Microbial diversity within trips, fig.height=9, fig.width=9, , fig.align='center', fig.cap="Bacteroidetes Shannon index", eval=TRUE, message = FALSE, warning=FALSE, echo=TRUE}
# Shannon diversity
megan_genus_shannon <- diversity(t(otu_table(megan_genus_abundant)), index = "shannon")

# Preparing the objects to visualise as boxplots
# Shannon
megan_genus_shannon_boxplots <- as.data.frame(megan_genus_shannon)
megan_genus_shannon_boxplots <- tibble::rownames_to_column(megan_genus_shannon_boxplots, "Sample_ID")
megan_genus_shannon_boxplots <- left_join(megan_genus_shannon_boxplots,
                                          metadata %>% rownames_to_column("Sample_ID"))

# Getting median and SD: https://stackoverflow.com/questions/13372734/how-to-display-the-median-value-in-a-faceted-boxplot-in-ggplot
Shannon_numerical_summ <- ddply(megan_genus_shannon_boxplots,
                                              .(Sampling_trip),
                                              summarize,
                                              med = median(megan_genus_shannon),
                                              SD = sd(megan_genus_shannon))

# Plotting
ggplot(megan_genus_shannon_boxplots, aes(y = megan_genus_shannon, x = Sampling_trip)) + # Shannon index
  geom_boxplot(aes(fill=factor(Sampling_trip)), outlier.shape = NA) +
  geom_jitter(size=1.2, alpha=0.5) + # adding actual data points
  geom_text(data = Shannon_numerical_summ, aes(y = med, label = round(med,2)),size = 4.5, vjust = -0.5) + # adding median as text
  geom_text(data = Shannon_numerical_summ, aes(y = SD, label = round(SD,2)),size = 4.5, vjust = -0.5) + # adding median as text
  scale_fill_manual(values=c("indianred", # Sampling trip 1
                                "indianred4", # Sampling trip 2 
                                "red3", # Sampling trip 3
                                "slateblue")) + # Sampling trip 4
  coord_flip()+ # just flipping the plot
  labs(title="Alpha diversity - overall microbial communities", 
       subtitle="Across sampling trips",
       x="Sampling events",
       y="Shannon index")+
  theme(axis.text.x = element_text(angle = 90, hjust = 1, size = 12)) +
  theme_bw() +
  stat_pvalue_manual(megan_genus_shannon_boxplots %>% 
                       pairwise_wilcox_test(megan_genus_shannon ~ Sampling_trip) %>% 
                       add_xy_position())
# I will modify this manually in Inkscape
```

```{r overall communities diversity per trip median and SD values as numerical, fig.height=5, fig.width=9, fig.align='center', fig.cap="Bacteroidetes Shannon index", eval=TRUE, message = FALSE, warning=FALSE, echo=TRUE}
knitr::kable(Shannon_numerical_summ, caption = "Median and standard deviation for Shannon Index values, computed within trips.")
```


```{r overall communities diversity within trips Numerical output, eval=TRUE, message = FALSE, warning=FALSE, echo=TRUE}
# Numerical output
knitr::kable(megan_genus_shannon_boxplots %>% 
                       pairwise_wilcox_test(megan_genus_shannon ~ Sampling_trip),
             caption = "Wilcoxon rank sum test to compare median Shanon Diversity between trips, computed for overall communities.")
```

```{r PERMANOVA - GOs, fig.width = 33, fig.height=8, fig.align='center', echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
go.anosim <- left_join(otu_table(megan_GO_5_RA_no_rare) %>%
                         as.data.frame %>%
                         rownames_to_column("OTU"),
                         megan_GO_5_FUN %>% 
                         rownames_to_column("OTU")) %>% 
  unite(taxonomy, c(OTU, Rank1, Rank2, Rank3, Rank4, Rank5, Rank6#, Rank7, Rank8
                    ), sep = "; ") %>% 
  column_to_rownames("taxonomy")
# Removing rows with NAs, because ANOSIM does not take in missing vals
go.anosim <- na.omit(go.anosim)

# Object is ready to perform the test
ano_go <- anosim(t(go.anosim), 
                   sample_data(megan_GO_5_RA_no_rare)$Sampling_trip, 
                   distance = "bray", 
                   permutations = 9999)
# Results
ano_go
```

Pairwise PERMANOVA - GO terms (rank 5)

# Integrating microbial and environmental data

## Partial Mantel tests

```{r Source function to compute partial Mantel tests, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
# Compute the mantel tests - cite the source of where this is coming from!
multimantel<-function(distance,env.df,geo.dist){
  BCdist<-distance
  statistic<-NULL
  pval<-NULL
  n.obs<-NULL
  for (i in 1:ncol(env.df)){
    na.pos<-which(is.na(env.df[,i]))
    if (length(na.pos)>0) tmp<-mantel.partial(as.dist(as.matrix(BCdist)[-c(na.pos),-c(na.pos)]),dist(env.df[-c(na.pos),i]),as.dist(as.matrix(geo.dist)[-c(na.pos),-c(na.pos)]),method = "pearson",permutations = 1000) else tmp<-mantel.partial(BCdist,dist(env.df[,i]),geo.dist,method = "pearson",permutations = 1000)
    statistic<-c(statistic,tmp$statistic)
    pval<-c(pval,tmp$signif)
    n.obs<-c(n.obs,nrow(env.df)-length(na.pos))
  }
  data.frame(var=colnames(env.df),statistic,pval,p.corr=p.adjust(pval,method="bonferroni"),n.obs)
}

### Calculate Bray-Curtis dissimilarities - doing this on the Relative abundance data when rare taxa were excluded  
# Taxonomy
megan_genus_dist <- vegdist(t(otu_table(megan_genus_RA_no_rare)), method = "bray")
# GO terms 
megan_go_dist <- vegdist(t(otu_table(megan_GO_5_RA_no_rare)), method = "bray")

# Getting distances (in km) for IMOS-MGD sites - this is important because the Mantels will be corrected for geography
# Getting distances (in km) for IMOS-MGD sites
metadata_Mantel <- sample_data(megan_genus_clr) %>% 
  as.matrix() %>% 
  as.data.frame() %>% 
  rownames_to_column("Sample_ID")

# Importing the coordinates
map_coords_Mantel <- read.csv("/home/markoterzin/Documents/PhD/Thesis/Chapter_2/Paper_drafts/the_analysis_is_finalised/Code/input_files/MARKO_for_eReefs_Lats_Longs.csv")
map_coords_Mantel <- left_join(metadata_Mantel[,c(1,2)], map_coords_Mantel, by = c("REEF_NAME" = "name"))
# map_coords <- map_coords %>% remove_rownames %>% column_to_rownames(var="Sample_ID")
map_coords_Mantel$REEF_NAME <- NULL
names(map_coords_Mantel)[names(map_coords_Mantel) == 'Sample_ID'] <- 'name'
# Setting first column as row names
map_coords_Mantel <- map_coords_Mantel %>%
  remove_rownames %>%
  column_to_rownames(var="name")
# Need to reorder as pointDistance() function requires longitude to go first
map_coords_reorder <- map_coords_Mantel %>% 
  relocate(lon, lat)

# Probably better to compute this 4 times for each of the trips, but first need to make sure that this code works
IMOS_mar.dist.mat <- round(pointDistance(map_coords_reorder, lonlat=TRUE) / 1000)
rownames(IMOS_mar.dist.mat) <- metadata_Mantel$Sample_ID
colnames(IMOS_mar.dist.mat) <- metadata_Mantel$Sample_ID

# Trick here: Now adding one column to the front so that I can make the correlation plot for both midshelf and offshore reefs
metadata_Mantel <- cbind(a = 0, metadata_Mantel)

# partial Mantels - microbial taxa
partial_Mantel_taxa_res <- multimantel(as.dist(as.matrix(megan_genus_dist)[metadata_Mantel$a=="0",metadata_Mantel$a=="0"]), # Distance object, doing it only
                                 # for the epipelagic layer
                                 metadata_Mantel[metadata_Mantel$a=="0", colnames(metadata_Mantel[,c(26:42)])], # columns 26-42 will extract numerical values
                                 as.dist(as.matrix(IMOS_mar.dist.mat)[metadata_Mantel$a=="0", metadata_Mantel$a=="0"])) #[env.mat$epi=="EPI", env.mat$epi=="EPI"])) # I only need the geographic 
# distances, in km
knitr::kable(partial_Mantel_taxa_res %>% arrange(abs(statistic)),
             caption = "Partial Mantel tests assessing which physico-chemical parameters mat act as significant drivers of seawater microbiomes at the taxonomic level."
               )

# partial Mantels - microbial function (GO terms)
partial_Mantel_GOs_res <- multimantel(as.dist(as.matrix(megan_go_dist)[metadata_Mantel$a=="0",metadata_Mantel$a=="0"]), # Distance object, doing it only
                                 # for the epipelagic layer
                                 metadata_Mantel[metadata_Mantel$a=="0", colnames(metadata_Mantel[,c(26:42)])], # columns 26-42 will extract numerical values
                                 as.dist(as.matrix(IMOS_mar.dist.mat)[metadata_Mantel$a=="0", metadata_Mantel$a=="0"])) #[env.mat$epi=="EPI", env.mat$epi=="EPI"])) # I only need the geographic 
# distances, in km
knitr::kable(partial_Mantel_GOs_res %>% arrange(abs(statistic)),
             caption = "Partial Mantel tests assessing which physico-chemical parameters mat act as significant drivers of seawater microbiomes at the functional level."
               )
```

```{r partial Mantels as heatmaps, fig.height=7, fig.width=9, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
# WQ
partial_Mantel_cor.mat_taxa_WQ <- data.frame(Taxonomy=partial_Mantel_taxa_res$statistic,
#                            GO_terms=IMOS_res_go_WQ$statistic, # Transcriptome=res.metaT$statistic,
                            row.names = partial_Mantel_taxa_res$var)

partial_Mantel_pcor.mat_taxa_WQ <- data.frame(Taxonomy=partial_Mantel_taxa_res$pval,
#                             GO_terms=IMOS_res_go_WQ$p.corr, # Expression=res.exp$pval,
                             row.names = partial_Mantel_taxa_res$var)# ,Transcriptome=res.metaT$pval)
# Ordering - highest correlations first
# WQ_ordre<-order(apply(IMOS_cor.mat_WQ[,1:2],1,mean),decreasing = T)

# WQ
partial_Mantel_cor.mat_GOs_WQ <- data.frame(Functions=partial_Mantel_GOs_res$statistic,
                            #                            GO_terms=IMOS_res_go_WQ$statistic, # Transcriptome=res.metaT$statistic,
                            row.names = partial_Mantel_GOs_res$var)

partial_Mantel_pcor.mat_GOs_WQ <- data.frame(Functions=partial_Mantel_GOs_res$pval,
                             #                             GO_terms=IMOS_res_go_WQ$p.corr, # Expression=res.exp$pval,
                             row.names = partial_Mantel_GOs_res$var)# ,Transcriptome=res.metaT$pval)
# Ordering - highest correlations first
# WQ_ordre<-order(apply(IMOS_cor.mat_WQ[,1:2],1,mean),decreasing = T)

# Let's visualise this! as heatmaps:
# Taxonomy
heatmap_partial_Mantels_taxa_WQ <- ggcorrplot(partial_Mantel_cor.mat_taxa_WQ,#[ordre,], # Strongest drivers first
              p.mat=partial_Mantel_pcor.mat_taxa_WQ,#[ordre,], # Strongest drivers first
              insig = "blank",
              sig.level = 0.05,
              method = "square",
              lab=T,
              lab_size = 2.5,
              colors=c("#2874b2","white","#ba2832"))
heatmap_partial_Mantels_taxa_WQ
# Functions
heatmap_partial_Mantels_GOs_WQ <- ggcorrplot(partial_Mantel_cor.mat_GOs_WQ,#[ordre,], # Strongest drivers first
              p.mat=partial_Mantel_pcor.mat_GOs_WQ,#[ordre,], # Strongest drivers first
              insig = "blank",
              sig.level = 0.05,
              method = "square",
              lab=T,
              lab_size = 2.5,
              colors=c("#2874b2","white","#ba2832"))
heatmap_partial_Mantels_GOs_WQ
# Merging the two
# patchwork::wrap_plots(heatmap_partial_Mantels_taxa_WQ,
#                      heatmap_partial_Mantels_GOs_WQ,
#                      nrow = 2,
#                      ncol = 1)
```

## MINT sPLS

To (1) identify stable microbial indicators—both taxonomic and functional—that consistently respond to specific physico-chemical variables (e.g., nutrient loads, temperature, salinity) across broad spatio-temporal scales in the GBRwe extended a Sparse Partial Least Squares analysis (sPLS, see Lê Cao et al. 2008, 2009) widely used in microbial oceanography to correlate microbial data with continuous environmental metrics (see e.g. Guidi et al. 2016; Jameson et al. 2023; Priest et al. 2023) with a Multivariate INTegrative method (MINT, see Rohart et al., 2017a) to integrate data from four independent sampling trips
We also attempted MINT (Multivariate INTegration, Rohart et al. (2017b)), a method based on multi-group PLS that includes information about samples belonging to independent groups or studies (Eslami et al., 2014). In this context, the challenge was to accommodate for confounding effects between season and geography as each site was sampled only once in time and space. By using MINT sPLS, we aimed to identify microbial indicator taxa and genes that correlate to water chemistry metrics and are shared across the four sampling transects, regardless of geography or season. Similar to sPLS, in MINT sPLS we retained two dimensions and 50 features (microbial taxa or genes) per dimension for the X datasets, and all WQ metrics for the Y dataset.

```{r MINT sPLS, eval=TRUE, message = FALSE, warning=TRUE, echo=FALSE}
keepX <- c(50, 50)
# MINT sPLS - Taxa:WQ
mint.spls2.WQ.taxa <- mint.spls(X = OTUs_biplot_names,
                           Y = sample_data(megan_genus_clr)[,24:40],
                           ncomp = 2,
                           study = sample_data(megan_genus_clr)$Sampling_trip,
                           keepX = keepX, # 50 taxa on dims 1 and 2
                           mode = "regression")
# MINT sPLS - GOs:WQ
mint.spls2.WQ.GOs <- mint.spls(X = GOs_biplot_names,
                           Y = sample_data(megan_go_clr_5)[,24:40],
                           ncomp = 2,
                           study = sample_data(megan_go_clr_5)$Sampling_trip,
                           keepX = keepX, # 50 taxa on dims 1 and 2
                           mode = "regression")
```

```{r MINT sPLS Taxa-WQ sample plot, fig.height=5, fig.width=7, eval=TRUE, message = FALSE, warning=FALSE, echo=FALSE, fig.show='hide'}
mint.spls2.WQ.taxa.global.sample.plot <- plotIndiv(mint.spls2.WQ.taxa,
          group = sample_data(megan_genus_clr)$Sampling_trip,
          title = 'global MINT sPLS | Microbial Taxonomy-WQ',
          legend = T,
          rep.space = "XY-variate",
          col.per.group =c("indianred", # Sampling trip 1
                "indianred4", # Sampling trip 2 
                "red3", # Sampling trip 3
                "slateblue"), # Sampling trip 4
          legend.title = 'Sampling Trip')
```

```{r per study MINT sPLS Taxa-WQ sample plot, fig.height=8, fig.width=10, eval=TRUE, message = FALSE, warning=FALSE, echo=FALSE, fig.show='hide'}
mint.spls2.WQ.taxa.partial.sample.plot <- plotIndiv(mint.spls2.WQ.taxa,
          group = sample_data(megan_genus_clr)$Sampling_trip,
          title = 'partial MINT sPLS | Microbial Taxonomy-WQ',
          legend = T,
          ind.names = sample_names(megan_genus_clr),
          study = "all.partial",
          rep.space = "XY-variate",
          col.per.group =c("indianred", # Sampling trip 1
                "indianred4", # Sampling trip 2 
                "red3", # Sampling trip 3
                "slateblue"), # Sampling trip 4
          legend.title = 'Sampling Trip')
```

```{r Circle plot,  eval=TRUE, message = FALSE, warning=FALSE, echo=FALSE, fig.height=7, fig.width=7}
plotVar(mint.spls2.WQ.taxa)
```

But the MINT sPLS sample plot and circle correlation plots can be combined into a biplot, which will present both types of information.

Bellow is the code from Kim-Anh to create a MINT sPLS biplot:

```{r MINT sPLS2 biplot example code from Kim-Anh, eval=FALSE, echo=TRUE}
# create MINT sPLS object

data(stemcells)

# for the purpose of this example, we artificially
# create a continuous response Y by taking genes 1:10.

X = stemcells$gene[,-c(1:10)]
# renaming columns here so that I can identify the X and Y datasets
colnames(X) = paste('X', 1:ncol(X), sep = '.')

Y = stemcells$gene[,1:10]
# renaming columns here so that I can identify the X and Y datasets
colnames(Y) = paste('Y', 1:ncol(Y), sep = '.')


# here selecting only on X
res = mint.spls(X = X, Y = Y, ncomp = 2,
                keepX = c(10, 5), study = stemcells$study)

plotIndiv(res) # symbol represent study
plotVar(res)


library(ggrepel)

# INPUT ARGUMENTS
col = res$study  # color of samples according to the study
pch = res$study  # pch of samples according to the study
var.names.col = 'grey40'
var.names.size = 4
var.arrow.col.X = 'lightblue' # color of arrow + name for X data set (could be set as a vector length the number of variables selected in X)
var.arrow.col.Y = 'orange'
var.arrow.size = 0.5
var.arrow.length = 0.2
# components to be plotted
comp1 = 1
comp2 = 2
# input the MINT res object
object <- res
comp <- object$ncomp



## --- code starts here --------
# identify variables selected
selection.X <- rowSums(object$loadings$X[, 1:comp]) != 0 
selection.Y <- rowSums(object$loadings$Y[, 1:comp]) != 0 
loadings.X <- data.frame(object$loadings$X[selection.X, ])
loadings.Y <- data.frame(object$loadings$Y[selection.Y, ])

# if cutoff for the correlation circle plot (not used here, if you do I think things will break!)
cutoff <- 0
cors.X <- cor(object$X[, selection.X], object$variates$X[, 1:comp], use = 'pairwise' )
cors.Y <- cor(object$Y[, selection.Y], object$variates$Y[, 1:comp], use = 'pairwise' )
above.cutoff.X <- apply(cors.X, 1, function(x) any(abs(x) >= cutoff))
above.cutoff.Y <- apply(cors.Y, 1, function(x) any(abs(x) >= cutoff))
loadings.X <- loadings.X[above.cutoff.X,]
loadings.Y <- loadings.Y[above.cutoff.Y,]

# only representing the samples in the X space
variates <- object$variates$X
variates <- data.frame(variates)
## scaler of var vs sample coordinates
scaler <- max(variates, na.rm = TRUE)/max(abs(cors.X), na.rm = TRUE)
## potentially need to extend this for the Y scaler??

axes.titles <- c('Comp 1', 'Comp 2')

## ------------- outline of plot -----
gg_biplot <- 
  ggplot() + 
  theme_classic() +  
  labs(x = axes.titles[1], 
       y = axes.titles[2])
# ## vline and hline - you may want to comment this if you dont want these lines
gg_biplot <- gg_biplot + geom_vline(xintercept = 0, size = 0.3, col = 'grey75')
gg_biplot <- gg_biplot +  geom_hline(yintercept = 0, size = 0.3, col = 'grey75')
gg_biplot
# ------


# PLOT SAMPLES
    gg_biplot <- gg_biplot + 
      geom_point(aes(x = variates[, comp1], 
                     y = variates[, comp2], col = col, shape = pch),
                 size = 2,
                 show.legend = FALSE)
    gg_biplot

  
# PLOT VARIABLES
    # the correlations are rescaled - need to fiddle a bit here
    cors.X <- cors.X*scaler*0.8
    cors.Y <- cors.Y*scaler*0.8

      ## lines and arrows
    # X variables
      gg_biplot <-
        gg_biplot + geom_segment(
          aes(
            x = 0,
            y = 0,
            xend = cors.X[,comp1],
            yend = cors.X[,comp2],
          ),
          col = var.arrow.col.X,
          arrow = arrow(length = unit(var.arrow.length, "cm")),
          size = var.arrow.size,
          show.legend = FALSE
        )

      gg_biplot
      
      
      # Y variables
      gg_biplot <-
        gg_biplot + geom_segment(
          aes(
            x = 0,
            y = 0,
            xend = cors.Y[,comp1],
            yend = cors.Y[,comp2],
          ),
          col = var.arrow.col.Y,
          arrow = arrow(length = unit(var.arrow.length, "cm")),
          size = var.arrow.size,
          show.legend = FALSE
        )
      
      gg_biplot

    
    ## labels of X variables
    var.labels.X <- rownames(loadings.X) 
    gg_biplot <-
      gg_biplot + geom_text_repel(
        aes(
          x = cors.X[, comp1],
          y = cors.X[, comp2],
          label = var.labels.X),
        col = var.arrow.col.X)
    
    ## labels of Y variables
    var.labels.Y <- rownames(loadings.Y) 
    gg_biplot <-
      gg_biplot + geom_text_repel(
        aes(
          x = cors.Y[, comp1],
          y = cors.Y[, comp2],
          label = var.labels.Y),
        col = var.arrow.col.Y)

  gg_biplot

```

Which I applied on our data, first on taxa:

```{r MINT sPLS2 biplot Taxa-WQ plotting each of the layers, fig.height=10, fig.width=12, eval=TRUE, message = TRUE, warning=TRUE, echo=TRUE, fig.show='hide'}
# renaming columns here so that I can identify the X and Y datasets
metadata_MINT_biplot <- sample_data(megan_genus_clr)[,24:40]

# Let's make the names nicer for plotting:
old_names <- c("median_Chlorophyll_A_µg_L", "median_Phaeophytin_A_µg_L", 
               "median_PN_µM", "median_POC_µM", "median_PP_µM", 
               "median_DOC_µM", "median_PO4_µM", "median_NH4_µM", 
               "median_NO2_µM", "median_NO3_µM", "median_Si_µM", 
               "median_TDN_µM", "median_TDP_µM", "median_TSS_mg_L", 
               "SEAWATER_TEMPERATURE_2.5m_RV", "SALINITY_2.5m_RV", 
               "FLUORESCENCE_2.5m_RV")

new_names <- c("Ch-a", "Phaeo", "PN", "POC", "PP", 
               "DOC", "PO4", "NH4", "NO2", "NO3", "Si", "TDN", 
               "TDP", "TSS", "SST_2.5m_RV", "SALINITY_2.5m_RV", 
               "FLUORESCENCE_2.5m_RV")

# Find indices of old names in current column names
indices <- match(old_names, colnames(metadata_MINT_biplot))

# Replace old names with new names
colnames(metadata_MINT_biplot)[indices] <- new_names

# here selecting only on X
res = mint.spls(X = OTUs_biplot_names,
                Y = metadata_MINT_biplot,
                ncomp = 2,
                keepX = c(10, 10),
                study = sample_data(megan_genus_clr)$Sampling_trip)

plotIndiv(res)
plotIndiv(res,
          group = res$study,
#          title = 'global MINT sPLS | Microbial Taxonomy-WQ',
          legend = T,
          rep.space = "XY-variate",
          col.per.group =c("indianred", # Sampling trip 1
                "indianred4", # Sampling trip 2 
                "red3", # Sampling trip 3
                "slateblue"), # Sampling trip 4
#          legend.title = 'Sampling Trip'
          ) # symbol represent study
plotVar(res)


library(ggrepel)

# INPUT ARGUMENTS
col = res$study  # color of samples according to the study
pch = res$study  # pch of samples according to the study
var.names.col = 'grey40'
var.names.size = 4
var.arrow.col.X = 'lightblue' # color of arrow + name for X data set (could be set as a vector length the number of variables selected in X)
var.arrow.col.Y = 'orange'
var.arrow.size = 0.5
var.arrow.length = 0.2
# components to be plotted
comp1 = 1
comp2 = 2
# input the MINT res object
object <- res
comp <- object$ncomp

## --- code starts here --------
# identify variables selected
selection.X <- rowSums(object$loadings$X[, 1:comp]) != 0 
selection.Y <- rowSums(object$loadings$Y[, 1:comp]) != 0 
loadings.X <- data.frame(object$loadings$X[selection.X, ])
loadings.Y <- data.frame(object$loadings$Y[selection.Y, ])

# if cutoff for the correlation circle plot (not used here, if you do I think things will break!)
cutoff <- 0
cors.X <- cor(object$X[, selection.X], object$variates$X[, 1:comp], use = 'pairwise' )
cors.Y <- cor(object$Y[, selection.Y], object$variates$Y[, 1:comp], use = 'pairwise' )
above.cutoff.X <- apply(cors.X, 1, function(x) any(abs(x) >= cutoff))
above.cutoff.Y <- apply(cors.Y, 1, function(x) any(abs(x) >= cutoff))
loadings.X <- loadings.X[above.cutoff.X,]
loadings.Y <- loadings.Y[above.cutoff.Y,]

# only representing the samples in the X space
variates <- object$variates$X
variates <- data.frame(variates)

## scaler of var vs sample coordinates - added one for each data set
scaler.X <- max(object$variates$X, na.rm = TRUE)/max(abs(cors.X), na.rm = TRUE)
scaler.Y <- max(object$variates$Y, na.rm = TRUE)/max(abs(cors.Y), na.rm = TRUE)

axes.titles <- c('Comp 1', 'Comp 2')

## ------------- outline of plot -----
gg_biplot <- 
  ggplot() + 
  theme_classic() +  
  labs(x = axes.titles[1], 
       y = axes.titles[2])
# ## vline and hline - you may want to comment this if you dont want these lines
gg_biplot <- gg_biplot + geom_vline(xintercept = 0, size = 0.3, col = 'grey75')
gg_biplot <- gg_biplot +  geom_hline(yintercept = 0, size = 0.3, col = 'grey75')
gg_biplot
# ------


# PLOT SAMPLES
    gg_biplot <- gg_biplot + 
      geom_point(aes(x = variates[, comp1], 
                     y = variates[, comp2], col = col, shape = pch),
                 size = 2,
                 show.legend = FALSE) +
  scale_color_manual(values = c("indianred", # Sampling trip 1
                "indianred4", # Sampling trip 2 
                "red3", # Sampling trip 3
                "slateblue") # Sampling trip 4
                )
    gg_biplot

  
# PLOT VARIABLES
    # the correlations are rescaled - need to fiddle a bit here
    cors.X <- cors.X*scaler.X*0.7
    cors.Y <- cors.Y*scaler.Y*0.8

      ## lines and arrows
    # X variables
      gg_biplot <-
        gg_biplot + geom_segment(
          aes(
            x = 0,
            y = 0,
            xend = cors.X[,comp1],
            yend = cors.X[,comp2],
          ),
          col = var.arrow.col.X,
          arrow = arrow(length = unit(var.arrow.length, "cm")),
          size = var.arrow.size,
          show.legend = FALSE
        )

      gg_biplot
      
      
      # Y variables
      gg_biplot <-
        gg_biplot + geom_segment(
          aes(
            x = 0,
            y = 0,
            xend = cors.Y[,comp1],
            yend = cors.Y[,comp2],
          ),
          col = var.arrow.col.Y,
          arrow = arrow(length = unit(var.arrow.length, "cm")),
          size = var.arrow.size,
          show.legend = FALSE
        )
      
      gg_biplot

    
    ## labels of X variables
    var.labels.X <- rownames(loadings.X) 
    gg_biplot <-
      gg_biplot + geom_text_repel(
        aes(
          x = cors.X[, comp1],
          y = cors.X[, comp2],
          label = var.labels.X),
        col = var.arrow.col.X)
    
    ## labels of Y variables
    var.labels.Y <- rownames(loadings.Y) 
    gg_biplot <-
      gg_biplot + geom_text_repel(
        aes(
          x = cors.Y[, comp1],
          y = cors.Y[, comp2],
          label = var.labels.Y),
        col = var.arrow.col.Y)
```

```{r MINT sPLS2 biplot Taxa-WQ final plot, fig.height=10, fig.width=12, eval=TRUE, message = TRUE, warning=TRUE, echo=TRUE}
MINT_sPLS_taxa_biplot <-  gg_biplot
MINT_sPLS_taxa_biplot
```

And then also on functions:

```{r MINT sPLS2 biplot GOs-WQ plotting each of the layers, fig.height=10, fig.width=12, eval=TRUE, message = TRUE, warning=TRUE, echo=TRUE, fig.show='hide'}
# Plotting immediately here, all my objects are prepared already:
res = mint.spls(X = GOs_biplot_names,
                Y = metadata_MINT_biplot,
                ncomp = 2,
                keepX = c(10, 10),
                study = sample_data(megan_go_clr_5)$Sampling_trip)

plotIndiv(res)
plotIndiv(res,
          group = res$study,
#          title = 'global MINT sPLS | Microbial Function-WQ',
          legend = T,
          rep.space = "XY-variate",
          col.per.group =c("indianred", # Sampling trip 1
                "indianred4", # Sampling trip 2 
                "red3", # Sampling trip 3
                "slateblue"), # Sampling trip 4
#          legend.title = 'Sampling Trip'
          ) # symbol represent study
plotVar(res)

library(ggrepel)

# INPUT ARGUMENTS
col = res$study  # color of samples according to the study
pch = res$study  # pch of samples according to the study
var.names.col = 'grey40'
var.names.size = 4
var.arrow.col.X = 'lightblue' # color of arrow + name for X data set (could be set as a vector length the number of variables selected in X)
var.arrow.col.Y = 'orange'
var.arrow.size = 0.5
var.arrow.length = 0.2
# components to be plotted
comp1 = 1
comp2 = 2
# input the MINT res object
object <- res
comp <- object$ncomp


## --- code starts here --------
# identify variables selected
selection.X <- rowSums(object$loadings$X[, 1:comp]) != 0 
selection.Y <- rowSums(object$loadings$Y[, 1:comp]) != 0 
loadings.X <- data.frame(object$loadings$X[selection.X, ])
loadings.Y <- data.frame(object$loadings$Y[selection.Y, ])

# if cutoff for the correlation circle plot (not used here, if you do I think things will break!)
cutoff <- 0
cors.X <- cor(object$X[, selection.X], object$variates$X[, 1:comp], use = 'pairwise' )
cors.Y <- cor(object$Y[, selection.Y], object$variates$Y[, 1:comp], use = 'pairwise' )
above.cutoff.X <- apply(cors.X, 1, function(x) any(abs(x) >= cutoff))
above.cutoff.Y <- apply(cors.Y, 1, function(x) any(abs(x) >= cutoff))
loadings.X <- loadings.X[above.cutoff.X,]
loadings.Y <- loadings.Y[above.cutoff.Y,]

# only representing the samples in the X space
variates <- object$variates$X
variates <- data.frame(variates)

## scaler of var vs sample coordinates - added one for each data set
scaler.X <- max(object$variates$X, na.rm = TRUE)/max(abs(cors.X), na.rm = TRUE)
scaler.Y <- max(object$variates$Y, na.rm = TRUE)/max(abs(cors.Y), na.rm = TRUE)

axes.titles <- c('Comp 1', 'Comp 2')

## ------------- outline of plot -----
gg_biplot <- 
  ggplot() + 
  theme_classic() +  
  labs(x = axes.titles[1], 
       y = axes.titles[2])
# ## vline and hline - you may want to comment this if you dont want these lines
gg_biplot <- gg_biplot + geom_vline(xintercept = 0, size = 0.3, col = 'grey75')
gg_biplot <- gg_biplot +  geom_hline(yintercept = 0, size = 0.3, col = 'grey75')
gg_biplot
# ------


# PLOT SAMPLES
    gg_biplot <- gg_biplot + 
      geom_point(aes(x = variates[, comp1], 
                     y = variates[, comp2], col = col, shape = pch),
                 size = 2,
                 show.legend = FALSE) +
  scale_color_manual(values = c("indianred", # Sampling trip 1
                "indianred4", # Sampling trip 2 
                "red3", # Sampling trip 3
                "slateblue") # Sampling trip 4
                )
    gg_biplot

  
# PLOT VARIABLES
    # the correlations are rescaled - need to fiddle a bit here
    cors.X <- cors.X*scaler.X*0.7
    cors.Y <- cors.Y*scaler.Y*0.8

      ## lines and arrows
    # X variables
      gg_biplot <-
        gg_biplot + geom_segment(
          aes(
            x = 0,
            y = 0,
            xend = cors.X[,comp1],
            yend = cors.X[,comp2],
          ),
          col = var.arrow.col.X,
          arrow = arrow(length = unit(var.arrow.length, "cm")),
          size = var.arrow.size,
          show.legend = FALSE
        )

      gg_biplot
      
      
      # Y variables
      gg_biplot <-
        gg_biplot + geom_segment(
          aes(
            x = 0,
            y = 0,
            xend = cors.Y[,comp1],
            yend = cors.Y[,comp2],
          ),
          col = var.arrow.col.Y,
          arrow = arrow(length = unit(var.arrow.length, "cm")),
          size = var.arrow.size,
          show.legend = FALSE
        )
      
      gg_biplot

    
    ## labels of X variables
    var.labels.X <- rownames(loadings.X) 
    gg_biplot <-
      gg_biplot + geom_text_repel(
        aes(
          x = cors.X[, comp1],
          y = cors.X[, comp2],
          label = var.labels.X),
        col = var.arrow.col.X)
    
    ## labels of Y variables
    var.labels.Y <- rownames(loadings.Y) 
    gg_biplot <-
      gg_biplot + geom_text_repel(
        aes(
          x = cors.Y[, comp1],
          y = cors.Y[, comp2],
          label = var.labels.Y),
        col = var.arrow.col.Y)
```
    
```{r MINT sPLS2 biplot GOs-WQ final plot, fig.height=10, fig.width=12, eval=TRUE, message = TRUE, warning=TRUE, echo=TRUE}
MINT_sPLS_GOs_biplot <- gg_biplot
MINT_sPLS_GOs_biplot
```

But let's visualise these correlations as a heatmap:

```{r MINT sPLS Taxa-WQ on global dataset with OTU IDs, fig.width = 12, fig.height=15, fig.cap="MINT sPLS - Taxa/WQ. Microbial taxa that were identified as indicators are shown on the y axis, while WQ measurements are shown on the x axis. These molecular signatures are shared across the four sampling transects. The scale shows similarity values (partial correlations) between the X and Y variables selected across the first two MINT sPLS dimensions, and clustered with a complete Euclidean distance method. The color indicates either positive (red) or negative (blue) correlation.", eval=TRUE, message = FALSE, warning=FALSE, echo=TRUE}
# I want longer names, not just family and genus:
MINT_sPLS_ind_names_cim <- left_join(otu_table(megan_genus_clr) %>%
                              as.data.frame %>%
                              rownames_to_column("OTU"),
                            tax_table(megan_genus_clr) %>%
                              as.data.frame %>%
                              rownames_to_column("OTU")) %>%
  unite(taxonomy, c(Class, Order, Family, Genus, Species), sep = "; ") # Adding Taxonomy info
## Joining, by = "OTU"
MINT_sPLS_ind_names_cim <- as.character(MINT_sPLS_ind_names_cim$taxonomy)

# I am just making this object (cim_mint.spls2.WQ.taxa.OTUs) to merge with the stability scores based on OTU IDs
cim_mint.spls2.WQ.taxa.OTUs <- cim(mint.spls2.WQ.taxa,
    comp = 1:2,
    xlab = "WQ parameters",
    ylab = "Indicator microbial taxa",
    margins = c(19, # bottom
                28), # right
#    row.names = MINT_sPLS_ind_names_cim,
    symkey = FALSE,
    keysize = c(1, 0.4),
    title = "MINT sPLS Taxa/WQ (PCs 1 and 2)")
```

```{r MINT sPLS GOs-WQ on global dataset, fig.width = 16, fig.height=15, fig.cap="MINT sPLS - GOs/WQ. Microbial GO terms (genes and functions) that were identified as indicators are shown on the y axis, while WQ measurements are shown on the x axis. These molecular signatures are shared across the four sampling transects. The scale shows similarity values (partial correlations) between the X and Y variables selected across the first two sPLS dimensions, and clustered with a complete Euclidean distance method. The color indicates either positive (red) or negative (blue) correlation.", eval=TRUE, message = FALSE, warning=FALSE, echo=TRUE}
# I want longer names, not just family and genus:
MINT_sPLS_GOs_ind_names_cim <- left_join(otu_table(megan_go_clr_5) %>%
                              as.data.frame %>%
                              rownames_to_column("OTU"),
                            tax_table(megan_go_clr_5) %>%
                              as.data.frame %>%
                              rownames_to_column("OTU")) %>%
  unite(Functions, c(Rank3, Rank4, Rank5, Rank6), sep = "; ") # Adding Taxonomy info
## Joining, by = "OTU"
MINT_sPLS_GOs_ind_names_cim <- as.character(MINT_sPLS_GOs_ind_names_cim$Functions)

# I am just making this object (cim_mint.spls2.WQ.GOs) to merge with the stability scores based on OTU IDs
cim_mint.spls2.WQ.GOs <- cim(mint.spls2.WQ.GOs,
    comp = 1:2,
    xlab = "WQ parameters",
    ylab = "Indicator microbial GO terms (genes/functions)",
    margins = c(19, # bottom
                50), # right
#    row.names = MINT_sPLS_GOs_ind_names_cim,
    symkey = FALSE,
    keysize = c(1, 0.4),
    title = "MINT sPLS GOs/WQ (PCs 1 and 2)")
```

### Which of these associations are stable across sampling trips? ***L***eave-***O***ne-***G***roup-***O***ut ***C***ross ***V***alidation (***LOGOCV***)

Bellow is an example code from Kim-Anh to compute stability scores of indicators taxa/genes (selected on MINT sPLS dimension 1) across sampling trips.

```{r Kim-Anh code for stability MINT sPLS2, eval=FALSE, message = FALSE, warning=FALSE, echo=TRUE}
library(mixOmics)

data(stemcells)
# 4 studies
summary(stemcells$study)

## STABILITY analysis, just learn on 3 data sets at a time, leave one out study
#e.g. here removing study k

list.selected = NULL # initialise, then we will store the selected genes at each iteration

for(k in 1:4){  # each run: remove study k
train.studies = which(stemcells$study != k)
X = stemcells$gene[train.studies,]
Y = stemcells$celltype[train.studies]
studies = droplevels(stemcells$study[train.studies])
# do a few checks (here this is not extensive!)
summary(Y)
summary(studies)

res.train = mint.splsda(X = X, Y = Y, ncomp = 2, study = studies, keepX = c(50,50))

# append selected genes 
list.selected = c(list.selected, selectVar(res.train)$name, comp = 1)
}

length(list.selected) # ok, we should have 50 genes selected on comp 1 * 4 runs = 200

table(list.selected)/4  # where 4 is the number of runs / studies we have done
sort(table(list.selected)/4, decreasing = TRUE)
```

We applied this on indicator taxa:

```{r MINT sPLS2 Taxa-WQ stability for dim1, eval=TRUE, message = FALSE, warning=FALSE, echo=TRUE}
# 4 trips
summary(mint.spls2.WQ.taxa$study)
IMOS_studies <- c("Trip_01_Nov-Dec_2019",
                  "Trip_02_January_2020",
                  "Trip_03_February_2020",
                  "Trip_04_July_2020")
## STABILITY analysis, just learn on 3 data sets at a time, leave one out study
#e.g. here removing study k

list.selected = NULL # initialise, then we will store the selected genes at each iteration

for(k in IMOS_studies){  # each run: remove study k
train.studies = which(mint.spls2.WQ.taxa$study != k)
X = OTUs_biplot_names[train.studies,]
Y = metadata_MINT_biplot[train.studies,]
IMOS.studies = droplevels(mint.spls2.WQ.taxa$study[train.studies])
# do a few checks (here this is not extensive!)
summary(Y)
summary(IMOS.studies)

res.train = mint.spls(X = X, Y = Y, ncomp = 2, study = IMOS.studies, keepX = c(50,50))

# append selected genes 
list.selected = c(list.selected, selectVar(res.train)$X$name, comp = 1)
}

# Saving this as a separate object for taxa
list.selected.taxa <- list.selected

length(list.selected.taxa) # ok, we should have 50 genes selected on comp 1 * 4 runs = 200

table(list.selected.taxa)/4  # where 4 is the number of runs / studies we have done
sort(table(list.selected.taxa)/4, decreasing = TRUE)
```

Plotting MINT sPLS stability scores together with the heatmap, for taxa:

```{r MINT sPLS LOGOCV Stability scores dim1, fig.width = 6, fig.height=14, eval=TRUE, message = FALSE, warning=FALSE, echo=TRUE, fig.show='hide'}
# Row names in this object (mint.spls2.WQ.taxa.mat.cor) is how indicator taxa are ordered in the heatmap, Use this when setting the level in the aes() of ggplot2

# This is the table with Stability scores on dimension 1
MINT_sPLS_dim1_stability <- as.data.frame(table(list.selected.taxa)/4) %>%
  separate(col = "list.selected.taxa", # I am splitting this column
           sep = "_", # This is the separator
           into = c("OTU", "taxa")
           )
# Removing the taxa column - not needed:
MINT_sPLS_dim1_stability$taxa <- NULL

# getting names for taxa
OTUs_biplot_colnames <- left_join(otu_table(megan_genus_clr) %>%
                                    as.data.frame %>%
                                    rownames_to_column("OTU"),
                                  tax_table(megan_genus_clr) %>%
                                    as.data.frame %>%
                                    rownames_to_column("OTU")) %>%
  unite(taxonomy, c(Family, Genus), sep = "; ") # Adding Taxonomy info
## Joining, by = "OTU"
OTUs_biplot_colnames <- OTUs_biplot_colnames %>% 
  dplyr::select("OTU", "taxonomy")

# Merging:
MINT_sPLS_dim1_stability <- left_join(MINT_sPLS_dim1_stability,
                                      OTUs_biplot_colnames)

# Re-running MINT - I need OTUs only as names (not OTUs and taxonomy)
MINT_sPLS_similarity_scores_and_LOGOCV_taxa <- mint.spls(X = OTUs_biplot,
                           Y = sample_data(megan_genus_clr)[,24:40],
                           ncomp = 2,
                           study = sample_data(megan_genus_clr)$Sampling_trip,
                           keepX = keepX, # 50 taxa on dims 1 and 2
                           mode = "regression")

# I am just making this object (cim_mint.spls2.WQ.taxa.OTUs) to merge with the stability scores based on OTU IDs
MINT_sPLS_similarity_scores_and_LOGOCV_taxa <- cim(MINT_sPLS_similarity_scores_and_LOGOCV_taxa,
    comp = 1:2,
    xlab = "WQ parameters",
    ylab = "Indicator microbial taxa",
    margins = c(19, # bottom
                27), # right
#    row.names = MINT_sPLS_ind_names_cim,
    symkey = FALSE,
    keysize = c(1, 0.4),
    title = "MINT sPLS Taxa/WQ (PCs 1 and 2)")

# Extracting the correlation matrix from the MINT sPLS heatmap
mint.spls2.WQ.taxa.mat.cor <- MINT_sPLS_similarity_scores_and_LOGOCV_taxa$mat.cor
# Merging them!
MINT_sPLS_dim1_stability_merged <- left_join(as.data.frame(mint.spls2.WQ.taxa.mat.cor) %>% rownames_to_column("OTU"),
                                             MINT_sPLS_dim1_stability) # %>%
#  filter(if_any(everything(), ~ !is.na(Freq)))  # removing those that have NAs as stability scores
```

```{r MINT sPLS LOGOCV Stability scores taxa barplots shared in green, fig.width = 6, fig.height=14, eval=TRUE, message = FALSE, warning=FALSE, echo=TRUE}
# Barplots
MINT_sPLS_stability_plots_ordered.dim1 <- MINT_sPLS_dim1_stability_merged[,c(1, 19, 20)] %>% # Selecting OTU (1), Freq (19), and taxonomy (20) 
  ggplot(aes(y = factor(OTU, level = unique(row.names(as.data.frame(mint.spls2.WQ.taxa.mat.cor)))),
             x = Freq,
             fill =Freq > 0.25)) + # from Largest to smallest Stability
  geom_bar(stat = "identity") +
  scale_fill_manual(values = c("FALSE" = "grey40", "TRUE" = "seagreen3"), guide = FALSE) +
#  scale_y_discrete(limits=rev) + # Reversing the order to match the heatmap
  labs(y = 'MINT sPLS Indicator Microbes',
       x = "LOGOCV Stability score - dim 1",
       title = 'MINT sPLS Are these signals shared across trips?',
       subtitle = 'Leave One Group Out Cross Validation (LOGOCV)') +
      theme(axis.text.x = element_text(angle = 90, hjust = 1, size = 12), legend.position = "NONE")

MINT_sPLS_stability_plots_ordered.dim1

# Now exporting this for RawGraphs, this can go in Supplementary Material
RawGraphs_shared_taxa_MINT <- MINT_sPLS_stability_plots_ordered.dim1$data %>%
  as.data.frame() %>% 
  left_join(.,
            tax_table(megan_genus_clr) %>%
                                    as.data.frame %>%
                                    rownames_to_column("OTU")) %>%
#  unite(full_taxonomy, c(Rank1, Rank2, Rank3, Rank4, Rank5, Rank6, Rank7), sep = "; ") %>%  # Adding Taxonomy info
  dplyr::filter(if_any(everything(), ~ !is.na(Freq)))
# Exporting as csv
write.csv(RawGraphs_shared_taxa_MINT, file = "/home/markoterzin/Documents/PhD/Thesis/Chapter_2/Paper_drafts/the_analysis_is_finalised/Code/output_tables/RawGraphs_shared_taxa_MINT.csv", quote = F, row.names = F)
```

and indicator GO terms:

```{r MINT sPLS2 GOs-WQ stability for dim1, eval=TRUE, message = FALSE, warning=FALSE, echo=TRUE}
# 4 trips
summary(mint.spls2.WQ.GOs$study)
IMOS_studies <- c("Trip_01_Nov-Dec_2019",
                  "Trip_02_January_2020",
                  "Trip_03_February_2020",
                  "Trip_04_July_2020")
## STABILITY analysis, just learn on 3 data sets at a time, leave one out study
#e.g. here removing study k

list.selected = NULL # initialise, then we will store the selected genes at each iteration

for(k in IMOS_studies){  # each run: remove study k
train.studies = which(mint.spls2.WQ.GOs$study != k)
X = GOs_biplot_names[train.studies,]
Y = metadata_MINT_biplot[train.studies,]
IMOS.studies = droplevels(mint.spls2.WQ.GOs$study[train.studies])
# do a few checks (here this is not extensive!)
summary(Y)
summary(IMOS.studies)

res.train = mint.spls(X = X, Y = Y, ncomp = 2, study = IMOS.studies, keepX = c(50,50))

# append selected genes 
list.selected = c(list.selected, selectVar(res.train)$X$name, comp = 1)
}

# Saving this as a separate object for taxa
list.selected.GOs <- list.selected

length(list.selected.GOs) # ok, we should have 50 genes selected on comp 1 * 4 runs = 200

table(list.selected.GOs)/4  # where 4 is the number of runs / studies we have done
sort(table(list.selected.GOs)/4, decreasing = TRUE)
```

Plotting MINT sPLS stability scores together with the heatmap, for GO terms:

```{r MINT sPLS LOGOCV Stability scores GOs dim1, fig.width = 6, fig.height=14, eval=TRUE, message = FALSE, warning=FALSE, echo=TRUE, fig.show='hide'}
# Row names in this object (mint.spls2.WQ.taxa.mat.cor) is how indicator taxa are ordered in the heatmap, Use this when setting the level in the aes() of ggplot2

# This is the table with Stability scores on dimension 1
MINT_sPLS_dim1_stability_GOs <- as.data.frame(table(list.selected.GOs)/4) %>%
  separate(col = "list.selected.GOs", # I am splitting this column
           sep = "_", # This is the separator
           into = c("OTU", "GOs")
           )
# Removing the taxa column - not needed:
MINT_sPLS_dim1_stability_GOs$GOs <- NULL

# getting names for GOs
GOs_biplot_colnames <- left_join(otu_table(megan_go_clr_5) %>%
                                    as.data.frame %>%
                                    rownames_to_column("OTU"),
                                  tax_table(megan_go_clr_5) %>%
                                    as.data.frame %>%
                                    rownames_to_column("OTU")) %>%
  unite(Function, c(Rank3, Rank4, Rank5, Rank6), sep = "; ") # Adding Function info
## Joining, by = "OTU"
GOs_biplot_colnames <- GOs_biplot_colnames %>% 
  dplyr::select("OTU", "Function")

# Merging:
MINT_sPLS_dim1_stability_GOs <- left_join(MINT_sPLS_dim1_stability_GOs,
                                      GOs_biplot_colnames)

# Re-running MINT - I need GOs only as names (not GOs and actual annotations)
MINT_sPLS_similarity_scores_and_LOGOCV_GOs <- mint.spls(X = GOs_biplot,
                           Y = sample_data(megan_go_clr_5)[,24:40],
                           ncomp = 2,
                           study = sample_data(megan_go_clr_5)$Sampling_trip,
                           keepX = keepX, # 50 taxa on dims 1 and 2
                           mode = "regression")

# I am just making this object (cim_mint.spls2.WQ.taxa.OTUs) to merge with the stability scores based on OTU IDs
MINT_sPLS_similarity_scores_and_LOGOCV_GOs <- cim(MINT_sPLS_similarity_scores_and_LOGOCV_GOs,
    comp = 1:2,
    xlab = "WQ parameters",
    ylab = "Indicator microbial GO terms (genes/functions)",
    margins = c(19, # bottom
                50), # right
    row.names = MINT_sPLS_GOs_ind_names_cim,
    symkey = FALSE,
    keysize = c(1, 0.4),
    title = "MINT sPLS GOs/WQ (PCs 1 and 2)")

# Extracting the correlation matrix from the MINT sPLS heatmap
mint.spls2.WQ.GOs.mat.cor <- MINT_sPLS_similarity_scores_and_LOGOCV_GOs$mat
# Merging them!
MINT_sPLS_dim1_stability_merged_GOs <- left_join(as.data.frame(mint.spls2.WQ.GOs.mat.cor) %>% rownames_to_column("OTU"),
                                             MINT_sPLS_dim1_stability_GOs) # %>%
#  filter(if_any(everything(), ~ !is.na(Freq)))  # removing those that have NAs as stability scores
```

```{r MINT sPLS LOGOCV Stability scores GOs barplots shared in green, fig.width = 6, fig.height=14, eval=TRUE, message = FALSE, warning=FALSE, echo=TRUE}
# Barplots
MINT_sPLS_stability_plots_ordered.dim1_GOs <- MINT_sPLS_dim1_stability_merged_GOs[,c(1, 19, 20)] %>% # Selecting OTU (1), Freq (19), and taxonomy (20) 
  ggplot(aes(y = factor(OTU, level = unique(row.names(as.data.frame(mint.spls2.WQ.GOs.mat.cor)))),
             x = Freq,
             fill = Freq > 0.25)) + # from Largest to smallest Stability
  geom_bar(stat = "identity") +
  scale_fill_manual(values = c("FALSE" = "grey40", "TRUE" = "seagreen3"), guide = FALSE) +
#  scale_y_discrete(limits=rev) + # Reversing the order to match the heatmap
  labs(y = 'MINT sPLS Indicator GO terms',
       x = "LOGOCV Stability score - dim 1",
       title = 'MINT sPLS Are these signals shared across trips?',
       subtitle = 'Leave One Group Out Cross Validation (LOGOCV)') +
      theme(axis.text.x = element_text(angle = 90, hjust = 1, size = 12), legend.position = "NONE")

MINT_sPLS_stability_plots_ordered.dim1_GOs

# Now exporting this for RawGraphs, this can go in Supplementary Material
RawGraphs_shared_GOs_MINT <- MINT_sPLS_stability_plots_ordered.dim1_GOs$data %>%
  as.data.frame() %>% 
  left_join(.,
            tax_table(megan_go_clr_5) %>%
                                    as.data.frame %>%
                                    rownames_to_column("OTU")) %>%
#  unite(full_taxonomy, c(Rank1, Rank2, Rank3, Rank4, Rank5, Rank6, Rank7), sep = "; ") %>%  # Adding Taxonomy info
  dplyr::filter(if_any(everything(), ~ !is.na(Freq)))
# Exporting as csv
write.csv(RawGraphs_shared_taxa_MINT, file = "/home/markoterzin/Documents/PhD/Thesis/Chapter_2/Paper_drafts/the_analysis_is_finalised/Code/output_tables/RawGraphs_shared_GOs_MINT.csv", quote = F, row.names = F)
```

Numerical values - only for stable indicators (this will help me with text writing):

```{r MINT sPLS LOGOCV similarity scores taxa numerical, fig.width = 6, fig.height=14, eval=TRUE, message = FALSE, warning=FALSE, echo=TRUE}
# First extracting similarity values from the MINT sPLS heatmap
MINT_sPLS_mat.corr <- left_join(cim_mint.spls2.WQ.taxa.OTUs[["mat"]] %>% 
  as.data.frame() %>% 
  rownames_to_column("OTU"),
  megan_genus_clr@tax_table %>% # Adding taxonomy info too
    as.data.frame() %>% 
    rownames_to_column("OTU")
)
# Now adding the stability scores!
MINT_sPLS_mat.corr_and_LOGOCV <- left_join(MINT_sPLS_mat.corr, RawGraphs_shared_taxa_MINT[,1:2])
# Visualising as a table
knitr::kable(MINT_sPLS_mat.corr_and_LOGOCV, caption = "MINT sPLS - numerical representation of similarity scores (partial correlations).")
# I want to save this as a csv:
write.csv(MINT_sPLS_mat.corr_and_LOGOCV, file = "/home/markoterzin/Documents/PhD/Thesis/Chapter_2/Paper_drafts/the_analysis_is_finalised/Code/output_tables/MINT_sPLS_sim_and LOGOCV_stab_scores_taxa.csv", quote = F, row.names = F)
```

```{r MINT sPLS LOGOCV similarity scores GO terms numerical, fig.width = 6, fig.height=14, eval=TRUE, message = FALSE, warning=FALSE, echo=TRUE}
# First extracting similarity values from the MINT sPLS heatmap
MINT_sPLS_mat.corr.GOs <- left_join(cim_mint.spls2.WQ.GOs[["mat"]] %>% 
  as.data.frame() %>% 
  rownames_to_column("OTU"),
  megan_go_clr_5@tax_table %>% # Adding taxonomy info too
    as.data.frame() %>% 
    rownames_to_column("OTU")
)
# Now adding the stability scores!
MINT_sPLS_mat.corr_and_LOGOCV_GOs <- left_join(MINT_sPLS_mat.corr.GOs, RawGraphs_shared_GOs_MINT[,1:2])
# Visualising as a table
knitr::kable(MINT_sPLS_mat.corr_and_LOGOCV_GOs, caption = "MINT sPLS - numerical representation of similarity scores (partial correlations).")
# I want to save this as a csv:
write.csv(MINT_sPLS_mat.corr_and_LOGOCV_GOs, file = "/home/markoterzin/Documents/PhD/Thesis/Chapter_2/Paper_drafts/the_analysis_is_finalised/Code/output_tables/MINT_sPLS_sim_and LOGOCV_stab_scores_GOs.csv", quote = F, row.names = F)
```

## Do microbial taxa or genes/functions have a higher utility as indicators?

### Bray-Curtis similarity

Bray-Curtis similarity within replicates - is Function always more stable regardless of the hierarchical level?

```{r WITHIN REPLICATE Bray Curtis similarity for Genera, fig.height=3, fig.width=2, echo=TRUE, eval=TRUE}
# Taxa - Genus level
GENUS <- left_join(otu_table(megan_genus_abundant_known_phyla_only) %>%
                                    as.data.frame %>%
                                    rownames_to_column("OTU"),
                                  tax_table(megan_genus_abundant_known_phyla_only) %>%
                                    as.data.frame() %>% 
                                    rownames_to_column("OTU")) %>% 
  column_to_rownames("OTU")

# Now summarising raw counts at phylum level
GENUS <- ddply(GENUS, "Genus", numcolwise(sum)) %>% 
  column_to_rownames("Genus")

# Ready to compute raw abundances per sample - by dividing cell value with column sum
GENUS_RA <- GENUS
for (i in 1:(ncol(GENUS))) { # '2:' as the first column is not numeric
  GENUS_RA[i] <- GENUS_RA[i] / sum(GENUS_RA[i]) 
}
# Checking that rel abunds sum up to 1:
colSums(GENUS_RA)

bray_curtis_genus <- vegdist(t(GENUS_RA), # needs transposing
                            method = "bray", # I am computing Bray Curtis dissimilarity
                            diag = F, # diagonals will be 0 as it's on the same samples
                            upper = TRUE) %>% # Only the upper bit of the matrix
  as.matrix() %>%  # Output as matrix
  reshape2::melt() %>% # Getting it in long format to have pairwise comparisons - this is needed for visualisation
  left_join(., data.frame(sample_data(megan_genus_clr)) %>% 
              rownames_to_column("Var1")) %>% # adding reef names for first pair in the BC sim matrix
  dplyr::select(c("Var1", "Var2", "value", "REEF_NAME")) %>% # Selecting only columns of interest
  dplyr::rename(., REEF_NAME_for_Var1 = REEF_NAME) %>% # Rename to know that reef names correspond to first samples in the BC sim matrix
  left_join(., data.frame(sample_data(megan_genus_clr)) %>% 
              rownames_to_column("Var2")) %>% # Now merging based on Var2
  dplyr::select(c("Var1", "Var2", "value", "REEF_NAME_for_Var1", "REEF_NAME")) %>% # Selecting only columns of interest
  dplyr::rename(., REEF_NAME_for_Var2 = REEF_NAME) # Rename to know that reef names correspond to second samples in the BC sim matrix

bray_curtis_genus <- dplyr::filter(bray_curtis_genus, REEF_NAME_for_Var1==REEF_NAME_for_Var2) %>% # Only selecting pairs where the reef names are the same, that way I only pull out dissimilarity values from the same site - Within replicate level! 
  dplyr::filter(value != 0) %>%  # Removing values that have a zero - those are comparisons between the same replicate! We don't need those as dissimilarity will be zero (the same replicates are completely identical)
  mutate(Bray_Curtis_similarity = 1-value) %>%  # computing Bray Curtis similarity as 1 - BC dissimilarity
  left_join(., data.frame(sample_data(megan_genus_clr))[,c(1,2)] %>% # Only getting columns Reef name and Sampling trip
              rownames_to_column("Var1"))

bray_curtis_genus_median <- round(median(bray_curtis_genus$Bray_Curtis_similarity), digits = 2)
bray_curtis_genus_mean <- round(mean(bray_curtis_genus$Bray_Curtis_similarity), digits = 2)
bray_curtis_genus_SD <- round(sd(bray_curtis_genus$Bray_Curtis_similarity), digits = 2)
bray_curtis_genus_minimum <- round(min(bray_curtis_genus$Bray_Curtis_similarity), digits = 2)

# Plotting as bocplots:
bray_curtis_genus_boxplots <- bray_curtis_genus  %>%
  ggplot(aes(x = "Within replicate for taxa (Genus level)",
             y = Bray_Curtis_similarity,
#             col = Sampling_trip
             )) +
  geom_boxplot(show.legend = FALSE, outlier.shape = NA) +
    geom_jitter(aes(color=Sampling_trip), size=0.4, alpha=0.2) +
    stat_summary(aes(label = paste("Median:", bray_curtis_genus_median,
                                   "\nMean:", bray_curtis_genus_mean,
                                   "\nSD:", bray_curtis_genus_SD,
                                   "\nMin:", bray_curtis_genus_minimum)),
  fun.y = median,
  geom = "text",
  color = "black"
) + # median and SD as text  
    stat_summary(fun=mean,
               geom="point",
               shape=20,
               size=1.5,
               color="seagreen1",
               fill="seagreen1") + # Plotting the mean as a green dot! 
  scale_color_manual(values = c("indianred", # Sampling trip 1
                "indianred4", # Sampling trip 2 
                "red3", # Sampling trip 3
                "slateblue") # Sampling trip 4
    ) +
  ylim(0, 1) + # Fixing the y axis to show min and max Bray Curtis dissimilarity
  ylab("Bray-Curtis similarity") +
  theme(legend.position = "none")
```

```{r WITHIN REPLICATE Bray Curtis similarity for Family, fig.height=3, fig.width=2, echo=TRUE, eval=TRUE}
# Taxa - Family level
FAMILY <- left_join(otu_table(megan_genus_abundant_known_phyla_only) %>%
                                    as.data.frame %>%
                                    rownames_to_column("OTU"),
                                  tax_table(megan_genus_abundant_known_phyla_only) %>%
                                    as.data.frame() %>% 
                                    rownames_to_column("OTU")) %>% 
  column_to_rownames("OTU")

# Now summarising raw counts at phylum level
FAMILY <- ddply(FAMILY, "Family", numcolwise(sum)) %>% 
  column_to_rownames("Family")

# Ready to compute raw abundances per sample - by dividing cell value with column sum
FAMILY_RA <- FAMILY
for (i in 1:(ncol(FAMILY))) { # '2:' as the first column is not numeric
  FAMILY_RA[i] <- FAMILY_RA[i] / sum(FAMILY_RA[i]) 
}
# Checking that rel abunds sum up to 1:
colSums(FAMILY_RA)

bray_curtis_family <- vegdist(t(FAMILY_RA), # needs transposing
                            method = "bray", # I am computing Bray Curtis dissimilarity
                            diag = F, # diagonals will be 0 as it's on the same samples
                            upper = TRUE) %>% # Only the upper bit of the matrix
  as.matrix() %>%  # Output as matrix
  reshape2::melt() %>% # Getting it in long format to have pairwise comparisons - this is needed for visualisation
  left_join(., data.frame(sample_data(megan_genus_clr)) %>% 
              rownames_to_column("Var1")) %>% # adding reef names for first pair in the BC sim matrix
  dplyr::select(c("Var1", "Var2", "value", "REEF_NAME")) %>% # Selecting only columns of interest
  dplyr::rename(., REEF_NAME_for_Var1 = REEF_NAME) %>% # Rename to know that reef names correspond to first samples in the BC sim matrix
  left_join(., data.frame(sample_data(megan_genus_clr)) %>% 
              rownames_to_column("Var2")) %>% # Now merging based on Var2
  dplyr::select(c("Var1", "Var2", "value", "REEF_NAME_for_Var1", "REEF_NAME")) %>% # Selecting only columns of interest
  dplyr::rename(., REEF_NAME_for_Var2 = REEF_NAME) # Rename to know that reef names correspond to second samples in the BC sim matrix

bray_curtis_family <- dplyr::filter(bray_curtis_family, REEF_NAME_for_Var1==REEF_NAME_for_Var2) %>% # Only selecting pairs where the reef names are the same, that way I only pull out dissimilarity values from the same site - Within replicate level! 
  dplyr::filter(value != 0) %>%  # Removing values that have a zero - those are comparisons between the same replicate! We don't need those as dissimilarity will be zero (the same replicates are completely identical)
  mutate(Bray_Curtis_similarity = 1-value) %>%  # computing Bray Curtis similarity as 1 - BC dissimilarity
  left_join(., data.frame(sample_data(megan_genus_clr))[,c(1,2)] %>% # Only getting columns Reef name and Sampling trip
              rownames_to_column("Var1"))


bray_curtis_family_median <- round(median(bray_curtis_family$Bray_Curtis_similarity), digits = 2)
bray_curtis_family_mean <- round(mean(bray_curtis_family$Bray_Curtis_similarity), digits = 2)
bray_curtis_family_SD <- round(sd(bray_curtis_family$Bray_Curtis_similarity), digits = 2)
bray_curtis_family_minimum <- round(min(bray_curtis_family$Bray_Curtis_similarity), digits = 2)

# Plotting as bocplots:
bray_curtis_family_boxplots <- bray_curtis_family  %>%
  ggplot(aes(x = "Within replicate for taxa (family level)",
             y = Bray_Curtis_similarity,
#             col = Sampling_trip
             )) +
  geom_boxplot(show.legend = FALSE, outlier.shape = NA) +
    geom_jitter(aes(color=Sampling_trip), size=0.4, alpha=0.2) +
    stat_summary(aes(label = paste("Median:", bray_curtis_family_median,
                                   "\nMean:", bray_curtis_family_mean,
                                   "\nSD:", bray_curtis_family_SD,
                                   "\nMin:", bray_curtis_family_minimum)),
  fun.y = median,
  geom = "text",
  color = "black"
) + # median and SD as text  
      stat_summary(fun=mean,
               geom="point",
               shape=20,
               size=1.5,
               color="seagreen1",
               fill="seagreen1") + # Plotting the mean as a green dot! 
    scale_color_manual(values = c("indianred", # Sampling trip 1
                "indianred4", # Sampling trip 2 
                "red3", # Sampling trip 3
                "slateblue") # Sampling trip 4
    ) +
  ylim(0, 1) + # Fixing the y axis to show min and max Bray Curtis dissimilarity
  ylab("Bray-Curtis similarity") +
  theme(legend.position = "none")
```

```{r WITHIN REPLICATE Bray Curtis similarity for Order, fig.height=3, fig.width=2, echo=TRUE, eval=TRUE}
# Taxa - Order level
ORDER <- left_join(otu_table(megan_genus_abundant_known_phyla_only) %>%
                                    as.data.frame %>%
                                    rownames_to_column("OTU"),
                                  tax_table(megan_genus_abundant_known_phyla_only) %>%
                                    as.data.frame() %>% 
                                    rownames_to_column("OTU")) %>% 
  column_to_rownames("OTU")

# Now summarising raw counts at phylum level
ORDER <- ddply(ORDER, "Order", numcolwise(sum)) %>% 
  column_to_rownames("Order")

# Ready to compute raw abundances per sample - by dividing cell value with column sum
ORDER_RA <- ORDER
for (i in 1:(ncol(ORDER))) { # '2:' as the first column is not numeric
  ORDER_RA[i] <- ORDER_RA[i] / sum(ORDER_RA[i]) 
}
# Checking that rel abunds sum up to 1:
colSums(ORDER_RA)

bray_curtis_order <- vegdist(t(ORDER_RA), # needs transposing
                            method = "bray", # I am computing Bray Curtis dissimilarity
                            diag = F, # diagonals will be 0 as it's on the same samples
                            upper = TRUE) %>% # Only the upper bit of the matrix
  as.matrix() %>%  # Output as matrix
  reshape2::melt() %>% # Getting it in long format to have pairwise comparisons - this is needed for visualisation
  left_join(., data.frame(sample_data(megan_genus_clr)) %>% 
              rownames_to_column("Var1")) %>% # adding reef names for first pair in the BC sim matrix
  dplyr::select(c("Var1", "Var2", "value", "REEF_NAME")) %>% # Selecting only columns of interest
  dplyr::rename(., REEF_NAME_for_Var1 = REEF_NAME) %>% # Rename to know that reef names correspond to first samples in the BC sim matrix
  left_join(., data.frame(sample_data(megan_genus_clr)) %>% 
              rownames_to_column("Var2")) %>% # Now merging based on Var2
  dplyr::select(c("Var1", "Var2", "value", "REEF_NAME_for_Var1", "REEF_NAME")) %>% # Selecting only columns of interest
  dplyr::rename(., REEF_NAME_for_Var2 = REEF_NAME) # Rename to know that reef names correspond to second samples in the BC sim matrix

bray_curtis_order <- dplyr::filter(bray_curtis_order, REEF_NAME_for_Var1==REEF_NAME_for_Var2) %>% # Only selecting pairs where the reef names are the same, that way I only pull out dissimilarity values from the same site - Within replicate level! 
  dplyr::filter(value != 0) %>%  # Removing values that have a zero - those are comparisons between the same replicate! We don't need those as dissimilarity will be zero (the same replicates are completely identical)
  mutate(Bray_Curtis_similarity = 1-value) %>%  # computing Bray Curtis similarity as 1 - BC dissimilarity
  left_join(., data.frame(sample_data(megan_genus_clr))[,c(1,2)] %>% # Only getting columns Reef name and Sampling trip
              rownames_to_column("Var1"))

bray_curtis_order_median <- round(median(bray_curtis_order$Bray_Curtis_similarity), digits = 2)
bray_curtis_order_mean <- round(mean(bray_curtis_order$Bray_Curtis_similarity), digits = 2)
bray_curtis_order_SD <- round(sd(bray_curtis_order$Bray_Curtis_similarity), digits = 2)
bray_curtis_order_minimum <- round(min(bray_curtis_order$Bray_Curtis_similarity), digits = 2)

# Plotting as bocplots:
bray_curtis_order_boxplots <- bray_curtis_order  %>%
  ggplot(aes(x = "Within replicate for taxa (Order level)",
             y = Bray_Curtis_similarity,
#             col = Sampling_trip
             )) +
  geom_boxplot(show.legend = FALSE, outlier.shape = NA) +
    geom_jitter(aes(color=Sampling_trip), size=0.4, alpha=0.2) +
    stat_summary(aes(label = paste("Median:", bray_curtis_order_median,
                                   "\nMean:", bray_curtis_order_mean,
                                   "\nSD:", bray_curtis_order_SD,
                                   "\nMin:", bray_curtis_order_minimum)),
  fun.y = median,
  geom = "text",
  color = "black"
) + # median and SD as text  
      stat_summary(fun=mean,
               geom="point",
               shape=20,
               size=1.5,
               color="seagreen1",
               fill="seagreen1") + # Plotting the mean as a green dot! 
    scale_color_manual(values = c("indianred", # Sampling trip 1
                "indianred4", # Sampling trip 2 
                "red3", # Sampling trip 3
                "slateblue") # Sampling trip 4
    ) +
  ylim(0, 1) + # Fixing the y axis to show min and max Bray Curtis dissimilarity
  ylab("Bray-Curtis similarity") +
  theme(legend.position = "none")
```

```{r WITHIN REPLICATE Bray Curtis similarity for Class, fig.height=3, fig.width=2, echo=TRUE, eval=TRUE}
# Taxa - Class level
CLASS <- left_join(otu_table(megan_genus_abundant_known_phyla_only) %>%
                                    as.data.frame %>%
                                    rownames_to_column("OTU"),
                                  tax_table(megan_genus_abundant_known_phyla_only) %>%
                                    as.data.frame() %>% 
                                    rownames_to_column("OTU")) %>% 
  column_to_rownames("OTU")

# Now summarising raw counts at class level
CLASS <- ddply(CLASS, "Class", numcolwise(sum)) %>% 
  column_to_rownames("Class")

# Ready to compute raw abundances per sample - by dividing cell value with column sum
CLASS_RA <- CLASS
for (i in 1:(ncol(CLASS))) { # '2:' as the first column is not numeric
  CLASS_RA[i] <- CLASS_RA[i] / sum(CLASS_RA[i]) 
}
# Checking that rel abunds sum up to 1:
colSums(CLASS_RA)

bray_curtis_class <- vegdist(t(CLASS_RA), # needs transposing
                            method = "bray", # I am computing Bray Curtis dissimilarity
                            diag = F, # diagonals will be 0 as it's on the same samples
                            upper = TRUE) %>% # Only the upper bit of the matrix
  as.matrix() %>%  # Output as matrix
  reshape2::melt() %>% # Getting it in long format to have pairwise comparisons - this is needed for visualisation
  left_join(., data.frame(sample_data(megan_genus_clr)) %>% 
              rownames_to_column("Var1")) %>% # adding reef names for first pair in the BC sim matrix
  dplyr::select(c("Var1", "Var2", "value", "REEF_NAME")) %>% # Selecting only columns of interest
  dplyr::rename(., REEF_NAME_for_Var1 = REEF_NAME) %>% # Rename to know that reef names correspond to first samples in the BC sim matrix
  left_join(., data.frame(sample_data(megan_genus_clr)) %>% 
              rownames_to_column("Var2")) %>% # Now merging based on Var2
  dplyr::select(c("Var1", "Var2", "value", "REEF_NAME_for_Var1", "REEF_NAME")) %>% # Selecting only columns of interest
  dplyr::rename(., REEF_NAME_for_Var2 = REEF_NAME) # Rename to know that reef names correspond to second samples in the BC sim matrix

bray_curtis_class <- dplyr::filter(bray_curtis_class, REEF_NAME_for_Var1==REEF_NAME_for_Var2) %>% # Only selecting pairs where the reef names are the same, that way I only pull out dissimilarity values from the same site - Within replicate level! 
  dplyr::filter(value != 0) %>%  # Removing values that have a zero - those are comparisons between the same replicate! We don't need those as dissimilarity will be zero (the same replicates are completely identical)
  mutate(Bray_Curtis_similarity = 1-value) %>%  # computing Bray Curtis similarity as 1 - BC dissimilarity
  left_join(., data.frame(sample_data(megan_genus_clr))[,c(1,2)] %>% # Only getting columns Reef name and Sampling trip
              rownames_to_column("Var1"))

bray_curtis_class_median <- round(median(bray_curtis_class$Bray_Curtis_similarity), digits = 2)
bray_curtis_class_SD <- round(sd(bray_curtis_class$Bray_Curtis_similarity), digits = 2)
bray_curtis_class_minimum <- round(min(bray_curtis_class$Bray_Curtis_similarity), digits = 2)

# Plotting as bocplots:
bray_curtis_class_boxplots <- bray_curtis_class  %>%
  ggplot(aes(x = "Within replicate for taxa (Class level)",
             y = Bray_Curtis_similarity,
#             col = Sampling_trip
             )) +
  geom_boxplot(show.legend = FALSE, outlier.shape = NA) +
    geom_jitter(aes(color=Sampling_trip), size=0.4, alpha=0.2) +
    stat_summary(aes(label = paste("Median:", bray_curtis_class_median,
                                   "\nSD:", bray_curtis_class_SD,
                                   "\nMin:", bray_curtis_class_minimum)),
  fun.y = median,
  geom = "text",
  color = "black"
) + # median and SD as text  
      stat_summary(fun=mean,
               geom="point",
               shape=20,
               size=1.5,
               color="seagreen1",
               fill="seagreen1") + # Plotting the mean as a green dot! 
    scale_color_manual(values = c("indianred", # Sampling trip 1
                "indianred4", # Sampling trip 2 
                "red3", # Sampling trip 3
                "slateblue") # Sampling trip 4
    ) +
  ylim(0, 1) + # Fixing the y axis to show min and max Bray Curtis dissimilarity
  ylab("Bray-Curtis similarity") +
  theme(legend.position = "none")
```

```{r WITHIN REPLICATE Bray Curtis similarity for Phylum, fig.height=3, fig.width=2, echo=TRUE, eval=TRUE}
# Taxa - PHYLUM level
PHYLUM <- left_join(otu_table(megan_genus_abundant_known_phyla_only) %>%
                                    as.data.frame %>%
                                    rownames_to_column("OTU"),
                                  tax_table(megan_genus_abundant_known_phyla_only) %>%
                                    as.data.frame() %>% 
                                    rownames_to_column("OTU")) %>% 
  column_to_rownames("OTU")

# Now summarising raw counts at PHYLUM level
PHYLUM <- ddply(PHYLUM, "Phylum" , numcolwise(sum)) %>% 
  column_to_rownames("Phylum" )

# Ready to compute raw abundances per sample - by dividing cell value with column sum
PHYLUM_RA <- PHYLUM
for (i in 1:(ncol(PHYLUM))) { # '2:' as the first column is not numeric
  PHYLUM_RA[i] <- PHYLUM_RA[i] / sum(PHYLUM_RA[i]) 
}
# Checking that rel abunds sum up to 1:
colSums(PHYLUM_RA)

bray_curtis_phylum <- vegdist(t(PHYLUM_RA), # needs transposing
                            method = "bray", # I am computing Bray Curtis dissimilarity
                            diag = F, # diagonals will be 0 as it's on the same samples
                            upper = TRUE) %>% # Only the upper bit of the matrix
  as.matrix() %>%  # Output as matrix
  reshape2::melt() %>% # Getting it in long format to have pairwise comparisons - this is needed for visualisation
  left_join(., data.frame(sample_data(megan_genus_clr)) %>% 
              rownames_to_column("Var1")) %>% # adding reef names for first pair in the BC sim matrix
  dplyr::select(c("Var1", "Var2", "value", "REEF_NAME")) %>% # Selecting only columns of interest
  dplyr::rename(., REEF_NAME_for_Var1 = REEF_NAME) %>% # Rename to know that reef names correspond to first samples in the BC sim matrix
  left_join(., data.frame(sample_data(megan_genus_clr)) %>% 
              rownames_to_column("Var2")) %>% # Now merging based on Var2
  dplyr::select(c("Var1", "Var2", "value", "REEF_NAME_for_Var1", "REEF_NAME")) %>% # Selecting only columns of interest
  dplyr::rename(., REEF_NAME_for_Var2 = REEF_NAME) # Rename to know that reef names correspond to second samples in the BC sim matrix

bray_curtis_phylum <- dplyr::filter(bray_curtis_phylum, REEF_NAME_for_Var1==REEF_NAME_for_Var2) %>% # Only selecting pairs where the reef names are the same, that way I only pull out dissimilarity values from the same site - Within replicate level! 
  dplyr::filter(value != 0) %>%  # Removing values that have a zero - those are comparisons between the same replicate! We don't need those as dissimilarity will be zero (the same replicates are completely identical)
  mutate(Bray_Curtis_similarity = 1-value) %>%  # computing Bray Curtis similarity as 1 - BC dissimilarity
  left_join(., data.frame(sample_data(megan_genus_clr))[,c(1,2)] %>% # Only getting columns Reef name and Sampling trip
              rownames_to_column("Var1"))

bray_curtis_phylum_median <- round(median(bray_curtis_phylum$Bray_Curtis_similarity), digits = 2)
bray_curtis_phylum_SD <- round(sd(bray_curtis_phylum$Bray_Curtis_similarity), digits = 2)
bray_curtis_phylum_minimum <- round(min(bray_curtis_phylum$Bray_Curtis_similarity), digits = 2)

# Plotting as bocplots:
bray_curtis_phylum_boxplots <- bray_curtis_phylum  %>%
  ggplot(aes(x = "Within replicate for taxa (Phylum level)",
             y = Bray_Curtis_similarity,
#             col = Sampling_trip
             )) +
  geom_boxplot(show.legend = FALSE, outlier.shape = NA) +
    geom_jitter(aes(color=Sampling_trip), size=0.4, alpha=0.2) +
    stat_summary(aes(label = paste("Median:", bray_curtis_phylum_median,
                                   "\nSD:", bray_curtis_phylum_SD,
                                   "\nMin:", bray_curtis_phylum_minimum)),
  fun.y = median,
  geom = "text",
  color = "black"
) + # median and SD as text  
      stat_summary(fun=mean,
               geom="point",
               shape=20,
               size=1.5,
               color="seagreen1",
               fill="seagreen1") + # Plotting the mean as a green dot! 
    scale_color_manual(values = c("indianred", # Sampling trip 1
                "indianred4", # Sampling trip 2 
                "red3", # Sampling trip 3
                "slateblue") # Sampling trip 4
    ) +
  ylim(0, 1) + # Fixing the y axis to show min and max Bray Curtis dissimilarity
  ylab("Bray-Curtis similarity") +
  theme(legend.position = "none")
```

```{r WITHIN REPLICATE Bray Curtis similarity for GO terms Rank 3, fig.height=3, fig.width=2, echo=TRUE, eval=TRUE}
# GO terms - Rank 3
bray_curtis_GO3 <- vegdist(megan_GO_3_RA_no_rare@otu_table %>% # Getting my table with relative abundances
                              t() %>% # needs to be transposed though
                              as.data.frame(), # df
                            method = "bray", # I am computing Bray Curtis dissimilarity
                            diag = F, # diagonals will be 0 as it's on the same samples
                            upper = TRUE) %>% # Only the upper bit of the matrix
  as.matrix() %>%  # Output as matrix
  reshape2::melt() %>% # Getting it in long format to have pairwise comparisons - this is needed for visualisation
  left_join(., data.frame(sample_data(megan_go_clr_3)) %>% 
              rownames_to_column("Var1")) %>% # adding reef names for first pair in the BC sim matrix
  dplyr::select(c("Var1", "Var2", "value", "REEF_NAME")) %>% # Selecting only columns of interest
  dplyr::rename(., REEF_NAME_for_Var1 = REEF_NAME) %>% # Rename to know that reef names correspond to first samples in the BC sim matrix
  left_join(., data.frame(sample_data(megan_go_clr_3)) %>% 
              rownames_to_column("Var2")) %>% # Now merging based on Var2
  dplyr::select(c("Var1", "Var2", "value", "REEF_NAME_for_Var1", "REEF_NAME")) %>% # Selecting only columns of interest
  dplyr::rename(., REEF_NAME_for_Var2 = REEF_NAME) # Rename to know that reef names correspond to second samples in the BC sim matrix

bray_curtis_GO3 <- dplyr::filter(bray_curtis_GO3, REEF_NAME_for_Var1==REEF_NAME_for_Var2) %>% # Only selecting pairs where the reef names are the same, that way I only pull out dissimilarity values from the same site - Within replicate level! 
  dplyr::filter(value != 0) %>%  # Removing values that have a zero - those are comparisons between the same replicate! We don't need those as dissimilarity will be zero (the same replicates are completely identical)
  mutate(Bray_Curtis_similarity = 1-value) %>%  # computing Bray Curtis similarity as 1 - BC dissimilarity
  left_join(., data.frame(sample_data(megan_go_clr_3))[,c(1,2)] %>% # Only getting columns Reef name and Sampling trip
              rownames_to_column("Var1"))

bray_curtis_GO3_median <- round(median(bray_curtis_GO3$Bray_Curtis_similarity), digits = 2)
bray_curtis_GO3_SD <- round(sd(bray_curtis_GO3$Bray_Curtis_similarity), digits = 2)
bray_curtis_GO3_minimum <- round(min(bray_curtis_GO3$Bray_Curtis_similarity), digits = 2)

# Plotting as bocplots:
bray_curtis_GO3_boxplots <- bray_curtis_GO3  %>%
  ggplot(aes(x = "Within replicate for GO terms (Rank 3)",
             y = Bray_Curtis_similarity,
#             col = Sampling_trip
             )) +
  geom_boxplot(show.legend = FALSE, outlier.shape = NA) +
    geom_jitter(aes(color=Sampling_trip), size=0.4, alpha=0.2) +
    stat_summary(aes(label = paste("Median:", bray_curtis_GO3_median,
                                   "\nSD:", bray_curtis_GO3_SD,
                                   "\nMin:", bray_curtis_GO3_minimum)),
  fun.y = median,
  geom = "text",
  color = "black"
) + # median and SD as text
      stat_summary(fun=mean,
               geom="point",
               shape=20,
               size=1.5,
               color="seagreen1",
               fill="seagreen1") + # Plotting the mean as a green dot! 
    scale_color_manual(values = c("indianred", # Sampling trip 1
                "indianred4", # Sampling trip 2 
                "red3", # Sampling trip 3
                "slateblue") # Sampling trip 4
    ) +
  ylim(0, 1) + # Fixing the y axis to show min and max Bray Curtis dissimilarity
  ylab("Bray-Curtis similarity") +
  theme(legend.position = "none")
```

```{r WITHIN REPLICATE Bray Curtis similarity for GO terms Rank 4, fig.height=3, fig.width=2, echo=TRUE, eval=TRUE}
# GO terms - Rank 4
bray_curtis_GO4 <- vegdist(megan_GO_4_RA_no_rare@otu_table %>% # Getting my table with relative abundances
                              t() %>% # needs to be transposed though
                              as.data.frame(), # df
                            method = "bray", # I am computing Bray Curtis dissimilarity
                            diag = F, # diagonals will be 0 as it's on the same samples
                            upper = TRUE) %>% # Only the upper bit of the matrix
  as.matrix() %>%  # Output as matrix
  reshape2::melt() %>% # Getting it in long format to have pairwise comparisons - this is needed for visualisation
  left_join(., data.frame(sample_data(megan_go_clr_4)) %>% 
              rownames_to_column("Var1")) %>% # adding reef names for first pair in the BC sim matrix
  dplyr::select(c("Var1", "Var2", "value", "REEF_NAME")) %>% # Selecting only columns of interest
  dplyr::rename(., REEF_NAME_for_Var1 = REEF_NAME) %>% # Rename to know that reef names correspond to first samples in the BC sim matrix
  left_join(., data.frame(sample_data(megan_go_clr_4)) %>% 
              rownames_to_column("Var2")) %>% # Now merging based on Var2
  dplyr::select(c("Var1", "Var2", "value", "REEF_NAME_for_Var1", "REEF_NAME")) %>% # Selecting only columns of interest
  dplyr::rename(., REEF_NAME_for_Var2 = REEF_NAME) # Rename to know that reef names correspond to second samples in the BC sim matrix

bray_curtis_GO4 <- dplyr::filter(bray_curtis_GO4, REEF_NAME_for_Var1==REEF_NAME_for_Var2) %>% # Only selecting pairs where the reef names are the same, that way I only pull out dissimilarity values from the same site - Within replicate level! 
  dplyr::filter(value != 0) %>%  # Removing values that have a zero - those are comparisons between the same replicate! We don't need those as dissimilarity will be zero (the same replicates are completely identical)
  mutate(Bray_Curtis_similarity = 1-value) %>%  # computing Bray Curtis similarity as 1 - BC dissimilarity
  left_join(., data.frame(sample_data(megan_go_clr_4))[,c(1,2)] %>% # Only getting columns Reef name and Sampling trip
              rownames_to_column("Var1"))

bray_curtis_GO4_median <- round(median(bray_curtis_GO4$Bray_Curtis_similarity), digits = 2)
bray_curtis_GO4_mean <- round(mean(bray_curtis_GO4$Bray_Curtis_similarity), digits = 2)
bray_curtis_GO4_SD <- round(sd(bray_curtis_GO4$Bray_Curtis_similarity), digits = 2)
bray_curtis_GO4_minimum <- round(min(bray_curtis_GO4$Bray_Curtis_similarity), digits = 2)

# Plotting as bocplots:
bray_curtis_GO4_boxplots <- bray_curtis_GO4  %>%
  ggplot(aes(x = "Within replicate for GO terms (Rank 4)",
             y = Bray_Curtis_similarity,
#             col = Sampling_trip
             )) +
  geom_boxplot(show.legend = FALSE, outlier.shape = NA) +
    geom_jitter(aes(color=Sampling_trip), size=0.4, alpha=0.2) +
    stat_summary(aes(label = paste("Median:", bray_curtis_GO4_median,
                                   "\nMean:", bray_curtis_GO4_mean,
                                   "\nSD:", bray_curtis_GO4_SD,
                                   "\nMin:", bray_curtis_GO4_minimum)),
  fun.y = median,
  geom = "text",
  color = "black"
) + # median and SD as text  
      stat_summary(fun=mean,
               geom="point",
               shape=20,
               size=1.5,
               color="seagreen1",
               fill="seagreen1") + # Plotting the mean as a green dot! 
    scale_color_manual(values = c("indianred", # Sampling trip 1
                "indianred4", # Sampling trip 2 
                "red3", # Sampling trip 3
                "slateblue") # Sampling trip 4
    ) +
  ylim(0, 1) + # Fixing the y axis to show min and max Bray Curtis dissimilarity
  ylab("Bray-Curtis similarity") +
  theme(legend.position = "none")
```

```{r WITHIN REPLICATE Bray Curtis similarity for GO terms Rank 5, fig.height=3, fig.width=2, echo=TRUE, eval=TRUE}
# GO terms - Rank 4
bray_curtis_GO5 <- vegdist(megan_GO_5_RA_no_rare@otu_table %>% # Getting my table with relative abundances
                              t() %>% # needs to be transposed though
                              as.data.frame(), # df
                            method = "bray", # I am computing Bray Curtis dissimilarity
                            diag = F, # diagonals will be 0 as it's on the same samples
                            upper = TRUE) %>% # Only the upper bit of the matrix
  as.matrix() %>%  # Output as matrix
  reshape2::melt() %>% # Getting it in long format to have pairwise comparisons - this is needed for visualisation
  left_join(., data.frame(sample_data(megan_go_clr_5)) %>% 
              rownames_to_column("Var1")) %>% # adding reef names for first pair in the BC sim matrix
  dplyr::select(c("Var1", "Var2", "value", "REEF_NAME")) %>% # Selecting only columns of interest
  dplyr::rename(., REEF_NAME_for_Var1 = REEF_NAME) %>% # Rename to know that reef names correspond to first samples in the BC sim matrix
  left_join(., data.frame(sample_data(megan_go_clr_5)) %>% 
              rownames_to_column("Var2")) %>% # Now merging based on Var2
  dplyr::select(c("Var1", "Var2", "value", "REEF_NAME_for_Var1", "REEF_NAME")) %>% # Selecting only columns of interest
  dplyr::rename(., REEF_NAME_for_Var2 = REEF_NAME) # Rename to know that reef names correspond to second samples in the BC sim matrix

bray_curtis_GO5 <- dplyr::filter(bray_curtis_GO5, REEF_NAME_for_Var1==REEF_NAME_for_Var2) %>% # Only selecting pairs where the reef names are the same, that way I only pull out dissimilarity values from the same site - Within replicate level! 
  dplyr::filter(value != 0) %>%  # Removing values that have a zero - those are comparisons between the same replicate! We don't need those as dissimilarity will be zero (the same replicates are completely identical)
  mutate(Bray_Curtis_similarity = 1-value) %>%  # computing Bray Curtis similarity as 1 - BC dissimilarity
  left_join(., data.frame(sample_data(megan_go_clr_5))[,c(1,2)] %>% # Only getting columns Reef name and Sampling trip
              rownames_to_column("Var1"))

bray_curtis_GO5_median <- round(median(bray_curtis_GO5$Bray_Curtis_similarity), digits = 2)
bray_curtis_GO5_mean <- round(mean(bray_curtis_GO5$Bray_Curtis_similarity), digits = 2)
bray_curtis_GO5_SD <- round(sd(bray_curtis_GO5$Bray_Curtis_similarity), digits = 2)
bray_curtis_GO5_minimum <- round(min(bray_curtis_GO5$Bray_Curtis_similarity), digits = 2)

# Plotting as bocplots:
bray_curtis_GO5_boxplots <- bray_curtis_GO5  %>%
  ggplot(aes(x = "Within replicate for GO terms (Rank 5)",
             y = Bray_Curtis_similarity,
#             col = Sampling_trip
             )) +
  geom_boxplot(show.legend = FALSE, outlier.shape = NA) +
    geom_jitter(aes(color=Sampling_trip), size=0.4, alpha=0.2) +
    stat_summary(aes(label = paste("Median:", bray_curtis_GO5_median,
                                   "\nMean:", bray_curtis_GO5_mean,
                                   "\nSD:", bray_curtis_GO5_SD,
                                   "\nMin:", bray_curtis_GO5_minimum)),
  fun.y = median,
  geom = "text",
  color = "black"
) + # median and SD as text  
      stat_summary(fun=mean,
               geom="point",
               shape=20,
               size=1.5,
               color="seagreen1",
               fill="seagreen1") + # Plotting the mean as a green dot! 
    scale_color_manual(values = c("indianred", # Sampling trip 1
                "indianred4", # Sampling trip 2 
                "red3", # Sampling trip 3
                "slateblue") # Sampling trip 4
    ) +
  ylim(0, 1) + # Fixing the y axis to show min and max Bray Curtis dissimilarity
  ylab("Bray-Curtis similarity") +
  theme(legend.position = "none")
```

```{r WITHIN REPLICATE Bray Curtis similarity plot grid to have them all together, fig.height=4, fig.width=12, echo=TRUE, eval=TRUE}
plot_grid(bray_curtis_genus_boxplots, # taxonomy first:
          bray_curtis_family_boxplots,
          bray_curtis_order_boxplots,
          bray_curtis_class_boxplots,
          bray_curtis_phylum_boxplots,
          bray_curtis_GO5_boxplots, # Microbial function
          bray_curtis_GO4_boxplots,
          bray_curtis_GO3_boxplots,
ncol = 6, nrow = 1)
```

### Coupling sPLS and CV (4-fold x 50 repeats) to compute stability scores

The global phyloseq object was also split into four subsets (separate phyloseq objects within each of the four transects), to explore how microbial taxa/genes correlate to WQ metrics within each of the trips, focussing primarily on stability.

```{r Making subsets, eval=TRUE, message = FALSE, warning=FALSE, echo=FALSE, results='hide'}
# Taxonomy dataset
megan_genus_Trip1 <- subset_samples(megan_genus_clr, # Phyloseq object with all OTUs
                                    Sampling_trip=="Trip_01_Nov-Dec_2019")
megan_genus_Trip2 <- subset_samples(megan_genus_clr, # Phyloseq object with all OTUs
                                    Sampling_trip=="Trip_02_January_2020")
megan_genus_Trip3 <- subset_samples(megan_genus_clr, # Phyloseq object with all OTUs
                                    Sampling_trip=="Trip_03_February_2020")
megan_genus_Trip4 <- subset_samples(megan_genus_clr, # Phyloseq object with all OTUs
                                    Sampling_trip=="Trip_04_July_2020")
# Functional dataset
megan_go_Trip1 <- subset_samples(megan_go_clr_5, # Phyloseq object with all OTUs
                                    Sampling_trip=="Trip_01_Nov-Dec_2019")
megan_go_Trip2 <- subset_samples(megan_go_clr_5, # Phyloseq object with all OTUs
                                    Sampling_trip=="Trip_02_January_2020")
megan_go_Trip3 <- subset_samples(megan_go_clr_5, # Phyloseq object with all OTUs
                                    Sampling_trip=="Trip_03_February_2020")
megan_go_Trip4 <- subset_samples(megan_go_clr_5, # Phyloseq object with all OTUs
                                    Sampling_trip=="Trip_04_July_2020")

# Splitting the WQ metadata as well
metadata_Trip1 <- data.frame(sample_data(megan_go_Trip1))
# metadata_Trip1 <- metadata_Trip1 %>% 
#  remove_rownames %>% 
#  column_to_rownames("Sample_ID")
metadata_Trip2 <- data.frame(sample_data(megan_go_Trip2))
# metadata_Trip2 <- metadata_Trip2 %>% 
#  remove_rownames %>% 
#  column_to_rownames("Sample_ID")
metadata_Trip3 <- data.frame(sample_data(megan_go_Trip3))
# metadata_Trip3 <- metadata_Trip3 %>% 
#  remove_rownames %>% 
#  column_to_rownames("Sample_ID")

# Farquaharson has a zero value for PP! So imputing that missing value here
metadata_Trip3.imputed <- impute.nipals(X = metadata_Trip3[,24:40], ncomp = 2)
sum(is.na(metadata_Trip3.imputed)) # number of cells with NA
# It worked!

# Now checking what I did:
wq.id.na = is.na(metadata_Trip3[,24:40]) # determine position of NAs in dataframe
metadata_Trip3[,24:40][wq.id.na] # show original values
metadata_Trip3.imputed[wq.id.na] # show imputed values

metadata_Trip4 <- data.frame(sample_data(megan_go_Trip4))
# metadata_Trip4 <- metadata_Trip4 %>% 
#  remove_rownames %>% 
#  column_to_rownames("Sample_ID")
# If sample IDs are in rows, use this:
# metadata_Trip4 <- subset(metadata, row.names(metadata) %in% sample_names(megan_genus_Trip4))

# Also making the OTUs df per trip
OTUs_Trip1 <- as.data.frame(megan_genus_Trip1@otu_table)
OTUs_Trip1 <- t(OTUs_Trip1)
# Check dimensions of data
dim(OTUs_Trip1)
class(OTUs_Trip1)

OTUs_Trip2 <- as.data.frame(megan_genus_Trip2@otu_table)
OTUs_Trip2 <- t(OTUs_Trip2)
# Check dimensions of data
dim(OTUs_Trip2)
class(OTUs_Trip2)

OTUs_Trip3 <- as.data.frame(megan_genus_Trip3@otu_table)
OTUs_Trip3 <- t(OTUs_Trip3)
# Check dimensions of data
dim(OTUs_Trip3)
class(OTUs_Trip3)

OTUs_Trip4 <- as.data.frame(megan_genus_Trip4@otu_table)
OTUs_Trip4 <- t(OTUs_Trip4)
# Check dimensions of data
dim(OTUs_Trip4)
class(OTUs_Trip4)

### And GOs df per trip
GOs_Trip1 <- as.data.frame(megan_go_Trip1@otu_table)
GOs_Trip1 <- t(GOs_Trip1)
# Check dimensions of data
dim(GOs_Trip1)
class(GOs_Trip1)

GOs_Trip2 <- as.data.frame(megan_go_Trip2@otu_table)
GOs_Trip2 <- t(GOs_Trip2)
# Check dimensions of data
dim(GOs_Trip2)
class(GOs_Trip2)

GOs_Trip3 <- as.data.frame(megan_go_Trip3@otu_table)
GOs_Trip3 <- t(GOs_Trip3)
# Check dimensions of data
dim(GOs_Trip3)
class(GOs_Trip3)

GOs_Trip4 <- as.data.frame(megan_go_Trip4@otu_table)
GOs_Trip4 <- t(GOs_Trip4)
# Check dimensions of data
dim(GOs_Trip4)
class(GOs_Trip4)
```

### Trip 1

```{r sPLS Trip 1 Taxa-WQ, eval=TRUE, message = FALSE, warning=FALSE, echo=FALSE, cache=TRUE}
# Optimal parameters
keepX <- c(50, 50) # Keeping the same value across all trips!
trip1.final.spls2.WQ.taxa <- spls(X = OTUs_Trip1,
                            Y = metadata_Trip1[,24:40], # Choosing only medians!
                            ncomp = 2,
                            keepX = keepX,
                            mode = "regression")
```

```{r sPLS Trip 1 GOs-WQ, eval=TRUE, message = FALSE, warning=FALSE, echo=FALSE, cache=TRUE}
trip1.final.spls2.WQ.GOs <- spls(X = GOs_Trip1,
                            Y = metadata_Trip1[,24:40], # Choosing only medians!
                            ncomp = 2,
                            keepX = keepX,
                            mode = "regression")
```

We can examine how frequently each variable is selected when we subsample the data using the perf() function to measure how stable the signature is.

```{r Stability metrics Trip 1, fig.align='center', fig.height=5, fig.width=3, eval=TRUE, message = TRUE, warning=TRUE, echo=TRUE, cache=TRUE}
stab.trip1.final.spls2.WQ.taxa <- perf(trip1.final.spls2.WQ.taxa,
                                       validation = 'Mfold',
                                       folds = 4,
                                       nrepeat = 50)
stab.trip1.final.spls2.WQ.GOs <- perf(trip1.final.spls2.WQ.GOs,
                                       validation = 'Mfold',
                                       folds = 4,
                                       nrepeat = 50)
```

```{r Stability scores Trip 1 boxplots, fig.align='center', fig.height=6, fig.width=3, eval=TRUE, message = TRUE, warning=TRUE, echo=TRUE, cache=TRUE}
# Extract stability - Dimension 1
stab.Taxa.trip1.comp1 <- stab.trip1.final.spls2.WQ.taxa$features$stability.X$comp1
stab.GOs.trip1.comp1 <- stab.trip1.final.spls2.WQ.GOs$features$stability.X$comp1
# We extract the stability measures of only the variables selected in spls2
extr.stab.Taxa.trip1.comp1 <- stab.Taxa.trip1.comp1[selectVar(trip1.final.spls2.WQ.taxa,
comp =1)$X$name]
extr.stab.GOs.trip1.comp1 <- stab.GOs.trip1.comp1[selectVar(trip1.final.spls2.WQ.GOs,
comp =1)$X$name]

# Plotting stability scores as boxplots, while simultaneously doing the Wilcoxon rank sum test - are these differences statistically significant?

# Preparing the object first:
Wilcoxon_trip_1_stability <- bind_rows(as.data.frame(extr.stab.Taxa.trip1.comp1) %>%
                   dplyr::rename(., Stability_scores_Trip_1 = extr.stab.Taxa.trip1.comp1) %>%
                   mutate(Comparison = "1_Taxa"),
                 as.data.frame(extr.stab.GOs.trip1.comp1) %>%
                   dplyr::rename(., Stability_scores_Trip_1 = extr.stab.GOs.trip1.comp1) %>% 
                   mutate(Comparison = "2_Functions"))
# Exporting this as a numerical value as well:
write.csv(Wilcoxon_trip_1_stability, "/home/markoterzin/Documents/PhD/Thesis/Chapter_2/Paper_drafts/the_analysis_is_finalised/Code/output_tables/trip_1_sPLS_stability_scores.csv", row.names = F)

# Stability scores - getting median and SD: https://stackoverflow.com/questions/13372734/how-to-display-the-median-value-in-a-faceted-boxplot-in-ggplot
trip_1_stability_numerical_summ <- ddply(Wilcoxon_trip_1_stability,
                                              .(Comparison),
                                              summarize,
                                              med = median(Stability_scores_Trip_1),
                                              SD = sd(Stability_scores_Trip_1))

# Now plotting:
ggplot(Wilcoxon_trip_1_stability,
       aes(x = Comparison, y = Stability_scores_Trip_1)) +
  geom_boxplot(fill = "indianred", outlier.shape = NA) +
  geom_jitter(size=0.8, alpha=0.5) +
  geom_text(data = trip_1_stability_numerical_summ, aes(y = med, label = round(med,2)),size = 4.5, vjust = -0.5) + # adding median as text
  geom_text(data = trip_1_stability_numerical_summ, aes(y = SD, label = round(SD,2)),size = 4.5, vjust = -0.5) + # adding median as text  
  ylim(0,1) +
  labs(#x = "Microbial function",
       y = "Re-occurrence of indicator features at PC 1 (4-fold CV, 50 reps)"
       ) +
  theme_bw() +
  stat_pvalue_manual(Wilcoxon_trip_1_stability %>% 
                       pairwise_wilcox_test(Stability_scores_Trip_1 ~ Comparison) %>% 
                       add_xy_position())
# Then I edited this manually in Inkscape
```

### Trip 2

```{r sPLS Trip 2 Taxa-WQ, eval=TRUE, message = FALSE, warning=FALSE, echo=TRUE, cache=TRUE}
# Optimal parameters
keepX <- c(10, 10) # Keeping the same value across all trips!
trip2.final.spls2.WQ.taxa <- spls(X = OTUs_Trip2,
                            Y = metadata_Trip2[,24:40], # Choosing only medians!
                            ncomp = 2,
                            keepX = keepX,
                            mode = "regression")
```

```{r sPLS Trip 2 GOs-WQ, eval=TRUE, message = FALSE, warning=FALSE, echo=TRUE, cache=TRUE}
trip2.final.spls2.WQ.GOs <- spls(X = GOs_Trip2,
                            Y = metadata_Trip2[,24:40], # Choosing only medians!
                            ncomp = 2,
                            keepX = keepX,
                            mode = "regression")
```

We can examine how frequently each variable is selected when we subsample the data using the perf() function to measure how stable the signature is.

```{r Stability metrics Trip 2, fig.align='center', fig.height=5, fig.width=3, eval=TRUE, message = FALSE, warning=FALSE, echo=TRUE}
stab.trip2.final.spls2.WQ.taxa <- perf(trip2.final.spls2.WQ.taxa,
                                       validation = 'Mfold',
                                       folds = 4,
                                       nrepeat = 20)
stab.trip2.final.spls2.WQ.GOs <- perf(trip2.final.spls2.WQ.GOs,
                                       validation = 'Mfold',
                                       folds = 4,
                                       nrepeat = 50)
```

```{r Stability scores Trip 2 boxplots, fig.align='center', fig.height=6, fig.width=3, eval=TRUE, message = FALSE, warning=FALSE, echo=TRUE}
# Extract stability - Dimension 1
stab.Taxa.trip2.comp1 <- stab.trip2.final.spls2.WQ.taxa$features$stability.X$comp1
stab.GOs.trip2.comp1 <- stab.trip2.final.spls2.WQ.GOs$features$stability.X$comp1
# We extract the stability measures of only the variables selected in spls2
extr.stab.Taxa.trip2.comp1 <- stab.Taxa.trip2.comp1[selectVar(trip2.final.spls2.WQ.taxa,
comp =1)$X$name]
extr.stab.GOs.trip2.comp1 <- stab.GOs.trip2.comp1[selectVar(trip2.final.spls2.WQ.GOs,
comp =1)$X$name]

# Plotting stability scores as boxplots, while simultaneously doing the Wilcoxon rank sum test - are these differences statistically significant?

# Preparing the object first:
Wilcoxon_trip_2_stability <- bind_rows(as.data.frame(extr.stab.Taxa.trip2.comp1) %>%
                   dplyr::rename(., Stability_scores_Trip_2 = extr.stab.Taxa.trip2.comp1) %>%
                   mutate(Comparison = "1_Taxa"),
                 as.data.frame(extr.stab.GOs.trip2.comp1) %>%
                   dplyr::rename(., Stability_scores_Trip_2 = extr.stab.GOs.trip2.comp1) %>% 
                   mutate(Comparison = "2_Functions"))
# Exporting this as a numerical value as well:
write.csv(Wilcoxon_trip_2_stability, "/home/markoterzin/Documents/PhD/Thesis/Chapter_2/Paper_drafts/the_analysis_is_finalised/Code/output_tables/trip_2_sPLS_stability_scores.csv", row.names = F)

# Stability scores - getting median and SD: https://stackoverflow.com/questions/13372734/how-to-display-the-median-value-in-a-faceted-boxplot-in-ggplot
trip_2_stability_numerical_summ <- ddply(Wilcoxon_trip_2_stability,
                                              .(Comparison),
                                              summarize,
                                              med = median(Stability_scores_Trip_2),
                                              SD = sd(Stability_scores_Trip_2))

# Now plotting:
ggplot(Wilcoxon_trip_2_stability,
       aes(x = Comparison, y = Stability_scores_Trip_2)) +
  geom_boxplot(fill = "indianred4", outlier.shape = NA) +
  geom_jitter(size=0.8, alpha=0.5) +
  geom_text(data = trip_2_stability_numerical_summ, aes(y = med, label = round(med,2)),size = 4.5, vjust = -0.5) + # adding median as text
  geom_text(data = trip_2_stability_numerical_summ, aes(y = SD, label = round(SD,2)),size = 4.5, vjust = -0.5) + # adding median as text  
  ylim(0,1) +
  labs(#x = "Microbial function",
       y = "Re-occurrence of indicator features at PC 1 (4-fold CV, 50 reps)"
       ) +
  theme_bw() +
  stat_pvalue_manual(Wilcoxon_trip_2_stability %>% 
                       pairwise_wilcox_test(Stability_scores_Trip_2 ~ Comparison) %>% 
                       add_xy_position())
# Then I edited this manually in Inkscape
```

### Trip 3

```{r sPLS Trip 3 Taxa-WQ, eval=TRUE, message = FALSE, warning=FALSE, echo=TRUE, cache=TRUE}
# Optimal parameters
keepX <- c(10, 10) # Keeping the same value across all trips!
trip3.final.spls2.WQ.taxa <- spls(X = OTUs_Trip3,
                            Y = metadata_Trip3.imputed, # Choosing only medians!
                            ncomp = 2,
                            keepX = keepX,
                            mode = "regression")
```

```{r sPLS Trip 3 GOs-WQ, eval=TRUE, message = FALSE, warning=FALSE, echo=TRUE, cache=TRUE}
trip3.final.spls2.WQ.GOs <- spls(X = GOs_Trip3,
                            Y = metadata_Trip3.imputed, # Choosing only medians!
                            ncomp = 2,
                            keepX = keepX,
                            mode = "regression")
```

We can examine how frequently each variable is selected when we subsample the data using the perf() function to measure how stable the signature is.

```{r Stability metrics Trip 3, fig.align='center', fig.height=5, fig.width=3, eval=TRUE, message = TRUE, warning=TRUE, echo=TRUE, cache=TRUE}
stab.trip3.final.spls2.WQ.taxa <- perf(trip3.final.spls2.WQ.taxa,
                                       validation = 'Mfold',
                                       folds = 4,
                                       nrepeat = 20)
stab.trip3.final.spls2.WQ.GOs <- perf(trip3.final.spls2.WQ.GOs,
                                       validation = 'Mfold',
                                       folds = 4,
                                       nrepeat = 50)
```

```{r Stability scores Trip 3 boxplots, fig.align='center', fig.height=6, fig.width=3, eval=TRUE, message = FALSE, warning=FALSE, echo=TRUE}
# Extract stability - Dimension 1
stab.Taxa.trip3.comp1 <- stab.trip3.final.spls2.WQ.taxa$features$stability.X$comp1
stab.GOs.trip3.comp1 <- stab.trip3.final.spls2.WQ.GOs$features$stability.X$comp1
# We extract the stability measures of only the variables selected in spls2
extr.stab.Taxa.trip3.comp1 <- stab.Taxa.trip3.comp1[selectVar(trip3.final.spls2.WQ.taxa,
comp =1)$X$name]
extr.stab.GOs.trip3.comp1 <- stab.GOs.trip3.comp1[selectVar(trip3.final.spls2.WQ.GOs,
comp =1)$X$name]

# Plotting stability scores as boxplots, while simultaneously doing the Wilcoxon rank sum test - are these differences statistically significant?

# Preparing the object first:
Wilcoxon_trip_3_stability <- bind_rows(as.data.frame(extr.stab.Taxa.trip3.comp1) %>%
                   dplyr::rename(., Stability_scores_Trip_3 = extr.stab.Taxa.trip3.comp1) %>%
                   mutate(Comparison = "1_Taxa"),
                 as.data.frame(extr.stab.GOs.trip3.comp1) %>%
                   dplyr::rename(., Stability_scores_Trip_3 = extr.stab.GOs.trip3.comp1) %>% 
                   mutate(Comparison = "2_Functions"))
# Exporting this as a numerical value as well:
write.csv(Wilcoxon_trip_3_stability, "/home/markoterzin/Documents/PhD/Thesis/Chapter_2/Paper_drafts/the_analysis_is_finalised/Code/output_tables/trip_3_sPLS_stability_scores.csv", row.names = F)

# Stability scores - getting median and SD: https://stackoverflow.com/questions/13372734/how-to-display-the-median-value-in-a-faceted-boxplot-in-ggplot
trip_3_stability_numerical_summ <- ddply(Wilcoxon_trip_3_stability,
                                              .(Comparison),
                                              summarize,
                                              med = median(Stability_scores_Trip_3),
                                              SD = sd(Stability_scores_Trip_3))

# Now plotting:
ggplot(Wilcoxon_trip_3_stability,
       aes(x = Comparison, y = Stability_scores_Trip_3)) +
  geom_boxplot(fill = "red3", outlier.shape = NA) +
  geom_jitter(size=0.8, alpha=0.5) +
  geom_text(data = trip_3_stability_numerical_summ, aes(y = med, label = round(med,2)),size = 4.5, vjust = -0.5) + # adding median as text
  geom_text(data = trip_3_stability_numerical_summ, aes(y = SD, label = round(SD,2)),size = 4.5, vjust = -0.5) + # adding median as text  
  ylim(0,1) +
  labs(#x = "Microbial function",
       y = "Re-occurrence of indicator features at PC 1 (4-fold CV, 50 reps)"
       ) +
  theme_bw() +
  stat_pvalue_manual(Wilcoxon_trip_3_stability %>% 
                       pairwise_wilcox_test(Stability_scores_Trip_3 ~ Comparison) %>% 
                       add_xy_position())
# Then I edited this manually in Inkscape
```

### Trip 4

```{r sPLS Trip 4 Taxa-WQ, eval=TRUE, message = FALSE, warning=FALSE, echo=TRUE, cache=TRUE}
# Optimal parameters
keepX <- c(50, 50) # Keeping the same value across all trips!
trip4.final.spls2.WQ.taxa <- spls(X = OTUs_Trip4,
                            Y = metadata_Trip4[,24:40], # Choosing only medians!
                            ncomp = 2,
                            keepX = keepX,
                            mode = "regression")
```

```{r sPLS Trip 4 GOs-WQ, eval=TRUE, message = FALSE, warning=FALSE, echo=TRUE, cache=TRUE}
trip4.final.spls2.WQ.GOs <- spls(X = GOs_Trip4,
                            Y = metadata_Trip4[,24:40], # Choosing only medians!
                            ncomp = 2,
                            keepX = keepX,
                            mode = "regression")
```

We can examine how frequently each variable is selected when we subsample the data using the perf() function to measure how stable the signature is.

```{r Stability metrics Trip 4, fig.align='center', fig.height=5, fig.width=3, eval=TRUE, message = TRUE, warning=TRUE, echo=TRUE, cache=TRUE}
stab.trip4.final.spls2.WQ.taxa <- perf(trip4.final.spls2.WQ.taxa,
                                       validation = 'Mfold',
                                       folds = 4,
                                       nrepeat = 20)
stab.trip4.final.spls2.WQ.GOs <- perf(trip4.final.spls2.WQ.GOs,
                                       validation = 'Mfold',
                                       folds = 4,
                                       nrepeat = 50)
```

```{r Stability scores Trip 4 boxplots, fig.align='center', fig.height=6, fig.width=3, eval=TRUE, message = TRUE, warning=TRUE, echo=TRUE, cache=TRUE}
# Extract stability - Dimension 1
stab.Taxa.trip4.comp1 <- stab.trip4.final.spls2.WQ.taxa$features$stability.X$comp1
stab.GOs.trip4.comp1 <- stab.trip4.final.spls2.WQ.GOs$features$stability.X$comp1
# We extract the stability measures of only the variables selected in spls2
extr.stab.Taxa.trip4.comp1 <- stab.Taxa.trip4.comp1[selectVar(trip4.final.spls2.WQ.taxa,
comp =1)$X$name]
extr.stab.GOs.trip4.comp1 <- stab.GOs.trip4.comp1[selectVar(trip4.final.spls2.WQ.GOs,
comp =1)$X$name]

# Plotting stability scores as boxplots, while simultaneously doing the Wilcoxon rank sum test - are these differences statistically significant?

# Preparing the object first:
Wilcoxon_trip_4_stability <- bind_rows(as.data.frame(extr.stab.Taxa.trip4.comp1) %>%
                   dplyr::rename(., Stability_scores_Trip_4 = extr.stab.Taxa.trip4.comp1) %>%
                   mutate(Comparison = "1_Taxa"),
                 as.data.frame(extr.stab.GOs.trip4.comp1) %>%
                   dplyr::rename(., Stability_scores_Trip_4 = extr.stab.GOs.trip4.comp1) %>% 
                   mutate(Comparison = "2_Functions"))
# Exporting this as a numerical value as well:
write.csv(Wilcoxon_trip_4_stability, "/home/markoterzin/Documents/PhD/Thesis/Chapter_2/Paper_drafts/the_analysis_is_finalised/Code/output_tables/trip_4_sPLS_stability_scores.csv", row.names = F)

# Stability scores - getting median and SD: https://stackoverflow.com/questions/13372734/how-to-display-the-median-value-in-a-faceted-boxplot-in-ggplot
trip_4_stability_numerical_summ <- ddply(Wilcoxon_trip_4_stability,
                                              .(Comparison),
                                              summarize,
                                              med = median(Stability_scores_Trip_4),
                                              SD = sd(Stability_scores_Trip_4))

# Now plotting:
ggplot(Wilcoxon_trip_4_stability,
       aes(x = Comparison, y = Stability_scores_Trip_4)) +
  geom_boxplot(fill = "slateblue", outlier.shape = NA) +
  geom_jitter(size=0.8, alpha=0.5) +
  geom_text(data = trip_4_stability_numerical_summ, aes(y = med, label = round(med,2)),size = 4.5, vjust = -0.5) + # adding median as text
  geom_text(data = trip_4_stability_numerical_summ, aes(y = SD, label = round(SD,2)),size = 4.5, vjust = -0.5) + # adding median as text  
  ylim(0,1) +
  labs(#x = "Microbial function",
       y = "Re-occurrence of indicator features at PC 1 (4-fold CV, 50 reps)"
       ) +
  theme_bw() +
  stat_pvalue_manual(Wilcoxon_trip_4_stability %>% 
                       pairwise_wilcox_test(Stability_scores_Trip_4 ~ Comparison) %>% 
                       add_xy_position())
# Then I edited this manually in Inkscape
```
